! Grammar and token for CLScript
! in GOLD parser format to check correctness
! This is not an actual GOLD parser script, since it needs some lexical tricks 
! to make the language indentation based
!
! Chris Lomont Oct 2016
! format augmented EBNF
! X = A B C
! 'token' in single quotes
! 'A'-'Z' range
! [optional]
! {zero or more times}
! item* means 0 or more times
! item+ means 1 or more times
! (A|B)|C means (A or B) or C
! 
! EOL is end of line
! INDENT/UNINDENT - commands for parser to check indentation levels
! tokens and grammar
!

"Name"    = 'CL Script'
"Version" = '2016'
"Author"  = 'Chris Lomont' 
"About"   = 'CL Script is designed for small, embedded devices.'

"Case Sensitive" = True
"Start Symbol"   = <Declarations>

! ===================================================================
! Literal values
!
! Hex via 0xDEED, bin via 0b0010, decimal as usual
! float has decimal 0.121, allows +1.2e4, -1.1e-12
! All support underscore as separator like 1_000_000
!
! Strings are ASCII, no " or '. String interpolation via "test {x},{y}"
! ===================================================================

{Hex Digit}      = {digit} + [abcdefABCDEF]
{Bin Digit}      = [01]

! allow underscores in numbers after the first character
FloatLiteral     = ({digit})*'.'{digit}({digit})*(e('+'|'-')?{digit}+)?
DecLiteral       = {digit}({digit}|'_')*
BinLiteral       = 0b{Bin Digit}({Bin Digit}|'_')*
HexLiteral       = 0x{Hex Digit}({Hex Digit}|'_')*


{String Ch}      = {Printable} - ["\]
{Char Ch}        = {Printable} - ['']

StringLiteral    = '"'( {String Ch} | '\'{Printable} )* '"'
CharLiteral      = '' ( {Char Ch} | '\'{Printable} )''                 

! Identifiers
! start with a letter or underscore, add digits to the mix thereafter

{Id Head}        = {Letter} + [_]
{Id Tail}        = {Id Head} + {Digit} + [_]

ID               = {Id Head}{Id Tail}*   ! identifier is name

! For program structure, end of line and indent/dedent are tokens created by parser
! prefixed with ESC (ASCII 27) here to allow to pass Gold parser generator
EOL              = '```'  ! end of line
INDENT           = '``_'  ! indented lines
DEDENT           = '`__'  ! opposite of indent               
                 

! ===================================================================
! Comments - allow nested comments
! ===================================================================

Comment Block @= {Nesting = All, Advance = Character, Ending = Closed }
Comment Start  = '/*'
Comment End    = '*/'
Comment Line   = '//'

! ===================================================================
! each file has this form. It is a list of declarations, each ending with EOL
! ===================================================================
<Declarations> ::= <Declaration> <Declarations> ! a file is a list of zero or more declarations
                 | 
<Declaration>  ::= <Import Declaration>         ! include file or definitions, file inserted here
                 | <Attribute Declaration>      ! tag the next declaration with an attribute 
                 | <Enum Declaration>           ! define an enum
                 | <Type Declaration>           ! define a type
                 | <Function Declaration>       ! define or import a function
                 | <Variable Declaration>       ! define or import a variable                 

! ===================================================================
! import file for code and/or definitions. Prefer *.cls extension (Chris Lomont Script)
! ===================================================================
<Import Declaration> ::= 'import' StringLiteral EOL

! ===================================================================
! Attribute, possible on type, enum, variable, function, affects next one
!
! [Var "string1" ....]
! ===================================================================
<Attribute Declaration> ::= '[' ID <Attribute Strings> ']' EOL
! 0 or more strings             
<Attribute Strings>   ::= StringLiteral <Attribute Strings> | 

! ===================================================================
! Enumerations
!
! enum Bob
!    item1 = 0b0001
!    item2 = 0b0002
!    item3 = 1234
!    item5
!
! use via Bob.item1, can cast to/from i32 only, can & and | 
! stored in i32
!
! ===================================================================
<Enum Declaration> ::= 'enum' ID EOL INDENT <Enum Values> DEDENT
<Enum Values>      ::= <Enum Value> <Enum Values>
                     | <Enum Value>
<Enum Value>       ::= ID EOL
                     | ID '=' <Expression> EOL ! expression must be evaluated to integral literal at compile time

! ===================================================================
! basic types are built in types or user defined types
! ===================================================================
<Type>  ::= 'void'     ! empty type, used for functions returning nothing
          | 'bool'     ! boolean takes on true or false
          | 'i32'      ! signed 32 bit integer
          | 'r32'      ! 32 bit floating point, IEEE 754 if possible, perhaps s15.16 fixed point
          | 'string'   ! ASCII string
          | 'char'     ! a single byte ASCII character
          | ID         ! user type


! ===================================================================
! A Type Declaration defines a new type
!
! type Point
!    r32 x y
!    i32 r g b 
!    RGB color
! ===================================================================
<Type Declaration> ::= <Type Header> ID EOL INDENT <Type Member Definitions> DEDENT
<Type Header> ::= 'export' 'type' | 'type'            

! nonempty list of variable type and names
<Type Member Definitions>  ::= <Variable Type and Names> EOL <Type Member Definitions>
                             | <Variable Type and Names> EOL

! ===================================================================
! Variable Declaration
!
! export const i32 x y = 0 0      // multiple assignment, export constants
! i32 [4] arr = 0 1 2 3           // array assignment
! r32 [2,2] mat = 1.0 0.0 0.0 1.0 // multi array
! Vec3 a = 0.0 0.0 0.0            // fields
! import i32 a                    // import var name
! export r32 bob = 1.0            // export
! RGB color = 0.0 1.0 0.0         //
! const string [2] txts = "bob" "fred"  // constants
!
! ===================================================================
<Variable Declaration>    ::= 'import' <Import> EOL
                            | <Export> EOL !<Optional Export> <Optional Const> <Variable Definition> EOL

<Import> ::= <Variable Type and Names> | 'const' <Variable Type and Names> 
<Export> ::= <Rest> | 'export' <Rest> | 'export' 'const' <Rest> | 'const' <Rest>

<Rest> ::= <Variable Definition>                   

! deifne a variable, used globally and local to functions
<Variable Definition>     ::= <Variable Type and Names> <Variable Initializer>
               
! array can be single or multi dimensional                  
<Variable Type and Names> ::= <Type> <ID List> 
!                            | <Type> '[' <Expression List> ']' <ID List> 

<ID List>                 ::= <Array ID> ',' <ID List> | <Array ID>
                           
<Array ID> ::= ID | ID '[' <Expression List> ']'


<Variable Initializer>    ::= '=' <Initializer List>  |             ! initializer or not
<Initializer List>        ::= <Expression List>  
                           ! <Value> ',' <Initializer List> | <Value> ! one or more                      

!<Optional Const>          ::= const  | 
!<Optional Export>         ::= export |   otot                            

! ===================================================================
! Function  Declaration
! 
! import i32 sqrt (i32 value)
! import fail
!
! i32 times (i32 a, i32 b)
!    return a * b
!
! // call with swap (&a, &b)
! void swap (i32 & a, i32 & b)
!    i32 t = a
!    a = b
!    b = t
!    // how about a b = b a ? can do on stack nicely
!
! Vec op+(Vec a,Vec b)
!    r32 x = a.x + b.x
!    r32 y = a.y + b.y
!    return Vec(x,y)
!
! doNothing()
!   // nothing to do
!
! ===================================================================
! import has no definition block
<Function Declaration>    ::= 'import' <Function Prototype> 
                            | 'export' <Function Prototype> <Block> 
                            | <Function Prototype> <Block>

! return type, name, parameters, EOL
<Function Prototype> ::= <Type> <Function Name> '(' <Function Parameters> ')' EOL

! names are identifiers, or operator overloads                      
<Function Name> ::= ID
                  | 'op+'
                  | 'op-'
                  | 'op/'
                  | 'op*'
                  | 'op=='
                  | 'op!='
       
! 0 or more parameters
<Function Parameters>  ::= <Parameter> ',' <Function Parameters> | <Parameter> |   
                            
! parameter is type, optional reference, and name 
<Parameter>     ::= <Type> <Optional Reference> ID <Optional Empty Array>       

<Optional Empty Array> ::= '[' <Commas> ']' |
<Commas> ::= ',' <Commas> |                         

! reference allows passing built in type (i32, r32, etc) by reference
<Optional Reference>     ::= '&' | 

! ===================================================================
! Statements
! i32 a b c = 1 2 (3+4)
! for i in 1..10
! for i in a..b by 2
! for item in array
! if a 
!    clause1
! else
!    clause2
! a = b + c
! r g b = 1.0 2.0 3.0
! while ! done
!    if a = 5
!       break
! ===================================================================
! zero or more statements
<Statements> ::= <Statement> <Statements> |

<Statement>   ::= <Variable Definition> EOL
                | <Assign Statement>    EOL
                | <If Statement>
                | <For Statement>       
                | 'while' <Expression>    EOL <Block>
                | <Function Call>       EOL
                | <Jump Statement>      EOL

! handle 
!
! if a>0 
!   b = 1
!
! if a == 1
!   b = 1
! else
!    b = 2

! if a == 1
!   b = 1
! else if a == 3
!    b = 2
! else 
!    b = 3
<If Statement> ::= 'if' <Expression> EOL <If End>

<If End> ::= <Block>
           | <Block> 'else' EOL <Block>
           | <Block> <ElseIfs>
           | <Block> <ElseIfs> 'else' EOL <Block>

! 0 or more
<ElseIfs> ::= 'elseif' <Expression> EOL <Block> <ElseIfs> | 'elseif' <Expression> EOL <Block>

<Assign Statement>  ::= <Assign List> <Assign Operator> <Expression List>
<Assign Operator>   ::= '='
                     |  '+='
                     |  '-='
                     |  '*='
                     |  '/='
                     |  '^='
                     |  '&='
                     |  '|='
                     |  '%='
                     |  '>>='
                     |  '<<='
                     |  '>>>='
                     |  '<<<='

! a list of one or more things to assign expressions to
<Assign List> ::= <Assign Item> ',' <Assign List> | <Assign Item>
              
! one or more items to assign to
! also handle things like bob[10].field.array[12,23]
! how about a[0][3], example, char in a string from array?
! form is ID ('[' list '])
<Assign Item> ::= ID 
                | ID '.' <Assign Item>
                | ID '[' <Expression List> ']' 
                | ID '[' <Expression List> ']' '.' <Assign Item>

<Function Call> ::= ID '(' <Expression List> ')'
                

<Jump Statement>  ::= break 
                    | continue 
                    | return <Expression>
                    | return

<For Statement> ::= for ID in '[' <Expression> '..' <Expression> ']' EOL <Block>
                  | for ID in '[' <Expression> '..' <Expression> ']' by <Expression> EOL <Block>
                  | for ID in <Assign Item> EOL <Block>

! a block is an indented collection of statements
<Block>     ::= INDENT <Statements> DEDENT
             

! ===================================================================
! Here begins C style levels of operator precedence.
! An expression evaluates to a Value (a string, int, real, char, bool, user type)
! ===================================================================
! todo - fix all left recursion
! 0 or more expressions, used in assignments and function lists
<Expression List> ::= <Expression> ',' <Expression List> | <Expression> | 

<Expression> ::= <Op Or>

<Op Or>      ::= <Op Or> '||' <Op And> 
               | <Op And>

<Op And>     ::= <Op And> '&&' <Op BinOR>
               | <Op BinOR>

<Op BinOR>   ::= <Op BinOr> '|' <Op BinXOR>
               | <Op BinXOR>

<Op BinXOR>  ::= <Op BinXOR> '^' <Op BinAND>
               | <Op BinAND>

<Op BinAND>  ::= <Op BinAND> '&' <Op Equate>
               | <Op Equate>

<Op Equate>  ::= <Op Equate> '==' <Op Compare>
               | <Op Equate> '!=' <Op Compare>
               | <Op Compare>

<Op Compare> ::= <Op Compare> '<'  <Op Shift>
               | <Op Compare> '>'  <Op Shift>
               | <Op Compare> '<=' <Op Shift>
               | <Op Compare> '>=' <Op Shift>
               | <Op Shift>

<Op Shift>   ::= <Op Shift> '<<' <Op Rotate> 
               | <Op Shift> '>>' <Op Rotate>
               | <Op Rotate>

<Op Rotate>  ::= <Op Rotate> '<<<' <Op Add> ! rotate left
               | <Op Rotate> '>>>' <Op Add> ! rotate right
               | <Op Add>

<Op Add>     ::= <Op Add> '+' <Op Mult>
               | <Op Add> '-' <Op Mult>
               | <Op Mult>

<Op Mult>    ::= <Op Mult> '*' <Op Unary>
               | <Op Mult> '/' <Op Unary>
               | <Op Mult> '%' <Op Unary>
               | <Op Unary>

<Op Unary>   ::= '!'    <Op Unary> ! logical not
               | '~'    <Op Unary> ! bitwise invert  
               | '-'    <Op Unary> ! negate
               | '+'    <Op Unary> ! positive, for int, float
               | '++'   <Op Unary>
               | '--'   <Op Unary>
               | <Op Pointer> '++'
               | <Op Pointer> '--'
!               | '(' <Type> ')' <Op Unary>   !CAST - causes reduce-reduce conflict
               | <Op Pointer>

! todo - left recursive?!
<Op Pointer> ::= <Op Pointer> '.' <Value>               
               | <Op Pointer> '[' <Expression List> ']'
               | <Value>

<Value>      ::= BinLiteral
               | HexLiteral
               | DecLiteral  
               | StringLiteral
               | CharLiteral
               | FloatLiteral
               | <Bool Literal>
               | <Function Call>              
               | ID                           ! identifier
               | '(' <Expression> ')'         ! sub expression
               
<Bool Literal> ::= true | false
! END OF GRAMMAR
