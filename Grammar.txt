! Grammar and token for CLScript
! in GOLD parser format to check correctness
! This is not an actual GOLD parser script, since it needs some lexical tricks 
! to make the language indentation based
!
! Chris Lomont Oct 2016
! format augmented EBNF
! X = A B C
! 'token' in single quotes
! 'A'-'Z' range
! [optional]
! {zero or more times}
! item* means 0 or more times
! item+ means 1 or more times
! (A|B)|C means (A or B) or C
! 
! EOL is end of line
! INDENT/UNINDENT - commands for parser to check indentation levels
! tokens and grammar
!

"Name"    = 'CL Script'
"Version" = '2016'
"Author"  = 'Chris Lomont' 
"About"   = 'CL Script is designed for small, embedded devices.'

"Case Sensitive" = True
"Start Symbol"   = <Declarations>

! ===================================================================
! Literal values
!
! Hex via 0xDEED, bin via 0b0010, decimal as usual
! float has decimal 0.121, allows +1.2e4, -1.1e-12
! All support underscore as separator like 1_000_000
!
! Strings are ASCII, no " or '. String interpolation via "test {x},{y}"
! ===================================================================

{Hex Digit}      = {digit} + [abcdefABCDEF]
{Bin Digit}      = [01]

! allow underscores in numbers after the first character for numbers

! float has a digit on at least one side of a '.' and an optional suffix, no leading '_'
FloatLiteral     = (({digit}({digit}|'_')*'.'({digit}|'_')*) | (({digit}({digit}|'_')*)?'.'{digit}({digit}|'_')*))(e('+'|'-')?{digit}({digit}|'_')*)? 
                                     
DecLiteral       = {digit}({digit}|'_')*
BinLiteral       = 0b{Bin Digit}({Bin Digit}|'_')*
HexLiteral       = 0x{Hex Digit}({Hex Digit}|'_')*


{String Ch}      = {Printable} - ["\]
{Char Ch}        = {Printable} - ['']

StringLiteral    = '"'( {String Ch} | '\'{Printable} )* '"'
CharLiteral      = '' ( {Char Ch} | '\'{Printable} )''                 

! Identifiers
! start with a letter or underscore, add digits to the mix thereafter

{Id Head}        = {Letter} + [_]
{Id Tail}        = {Id Head} + {Digit} + [_]

ID               = {Id Head}{Id Tail}*   ! identifier is name

! For program structure, end of line and indent/dedent are tokens created by parser
! prefixed with ESC (ASCII 27) here to allow to pass Gold parser generator
EOL              = '`E' ! '```'  ! end of line
INDENT           = '`I' ! '``_'  ! indented lines
DEDENT           = '`U' ! '`__'  ! opposite of indent               

! allow multiple in most places
<EOLs> ::= EOL <EOLs> | EOL


! ===================================================================
! Comments - allow nested comments
! ===================================================================

Comment Block @= {Nesting = All, Advance = Character, Ending = Closed }
Comment Start  = '/*'
Comment End    = '*/'
Comment Line   = '//'

! ===================================================================
! each file has this form. It is a list of declarations, each ending with EOL
! ===================================================================
<Declarations> ::= <Declaration> <Declarations> ! a file is a list of zero or more declarations
                 | 
<Declaration>  ::= <Import Declaration>         ! include file or definitions, file inserted here
                 | <Module Declaration>         ! name the current module
                 | <Attribute Declaration>      ! tag the next declaration with an attribute 
                 | <Enum Declaration>           ! define an enum
                 | <Type Declaration>           ! define a type
                 | <Variable Declaration>       ! define or import a variable                 
                 | <Function Declaration>       ! define or import a function
                 | EOL                          ! allow blank lines

! ===================================================================
! import file for code and/or definitions. Prefer *.cls extension (Chris Lomont Script)
! ===================================================================
<Import Declaration> ::= 'import' StringLiteral EOL

! ===================================================================
! Name a module, which is a prefix for all items following
! ===================================================================
<Module Declaration> ::= 'module' ID EOL

! ===================================================================
! Attribute, possible on type, enum, variable, function, affects next one
!
! [Var "string1" ....]
! ===================================================================
<Attribute Declaration> ::= '[' ID <Attribute Strings> ']' EOL
! 0 or more strings             
<Attribute Strings>   ::= StringLiteral <Attribute Strings> | 

! ===================================================================
! Enumerations
!
! enum Bob
!    item1 = 0b0001
!    item2 = 0b0002
!    item3 = 1234
!    item5
!
! use via Bob.item1, can cast to/from i32 only, can & and | 
! stored in i32
!
! ===================================================================
<Enum Declaration> ::= 'enum' ID <EOLs> INDENT <Enum Values> DEDENT
<Enum Values>      ::= <Enum Value> <Enum Values>
                     | <Enum Value>
<Enum Value>       ::= ID <EOLs>
                     | ID '=' <Expression> <EOLs> ! expression must be evaluated to integral literal at compile time

! ===================================================================
! basic types are built in types or user defined types
! ===================================================================
<Type>  ::= 'bool'     ! boolean takes on true or false
          | 'i32'      ! signed 32 bit integer
          | 'r32'      ! 32 bit floating point, IEEE 754 if possible, perhaps s15.16 fixed point
          | 'string'   ! ASCII string
          | 'char'     ! a single byte ASCII character
          | ID         ! user type


! ===================================================================
! A Type Declaration defines a new type
!
! type Point
!     r32 x y
!     i32 r g b 
!     RGB color[3],c2
! export type Type2
!     i32 a
! ===================================================================
<Type Declaration> ::= <Type Header> ID <EOLs> INDENT <Type Member Definitions> DEDENT
<Type Header> ::= 'export' 'type' | 'type'            

! nonempty list of variable type and names
<Type Member Definitions>  ::= <Variable Type and Names> <EOLs> <Type Member Definitions>
                             | <Variable Type and Names> <EOLs>

! ===================================================================
! Variable Declaration
!
! export const i32 x,y = 0,0      // multiple assignment, export constants
! i32 [4] arr = 0,1,2,3           // array assignment
! r32 [2,2] mat = 1.0,0.0,0.0,1.0 // multi array
! Vec3 a = 0.0,0.0,0.0            // fields
! import i32 a                    // import var name
! export r32 bob = 1.0            // export
! RGB color = 0.0,1.0,0.0         //
! const string [2] txts = "bob" "fred"  // constants
!
! ===================================================================
<Variable Declaration>    ::= 'import' <Import> EOL
                            | <Export> EOL 

<Import> ::= <Variable Type and Names> | 'const' <Variable Type and Names> 
<Export> ::= <Rest> | 'export' <Rest> | 'export' 'const' <Rest> | 'const' <Rest>

<Rest> ::= <Variable Definition>                   

! deifne a variable, used globally and local to functions
<Variable Definition>     ::= <Variable Type and Names> <Variable Initializer>
               
! array can be single or multi dimensional                  
<Variable Type and Names> ::= <Type> <ID List> 

<ID List>                 ::= <Array ID> ',' <ID List> | <Array ID>
                           
<Array ID> ::= ID | ID '[' <Expression List> ']'


<Variable Initializer>    ::= '=' <Initializer List>  |             ! initializer or not
<Initializer List>        ::= <Expression List>  
                           ! <Value> ',' <Initializer List> | <Value> ! one or more                      

! ===================================================================
! Function  Declaration
! 
! import i32 sqrt (i32 value)
! import fail
!
! i32 times (i32 a, i32 b)
!    return a * b
!
! // call with swap (&a, &b), no return value
! () swap (i32 & a, i32 & b)
!    i32 t = a
!    a = b
!    b = t
!    // how about a b = b a ? can do on stack nicely
!
! Vec op+(Vec a,Vec b)
!    r32 x = a.x + b.x
!    r32 y = a.y + b.y
!    return Vec(x,y)
!
! () doNothing()
!   // nothing to do
! 
! (i32,bool) ret2() // multiple return
!     return 1,true
!
! ===================================================================
! import has no definition block
<Function Declaration>    ::= 'import' <Function Prototype> 
                            | 'export' <Function Prototype> <Block> 
                            | <Function Prototype> <Block>

! return type, name, parameters, EOL
<Function Prototype> ::= '(' <Return Types> ')' <Function Name> '(' <Function Parameters> ')' EOL

!0 or more types
<Return Types>       ::= <Type> ',' <Return Types> | <Type> |

! names are identifiers, or operator overloads                      
<Function Name> ::= ID
                  | 'op+'
                  | 'op-'
                  | 'op/'
                  | 'op*'
                  | 'op=='
                  | 'op!='
       
! 0 or more parameters
<Function Parameters>  ::= <Parameter> ',' <Function Parameters> | <Parameter> |   
                            
! parameter is type, optional reference, and name 
<Parameter>     ::= <Type> <Optional Reference> ID <Optional Empty Array>       

<Optional Empty Array> ::= '[' <Commas> ']' |
<Commas> ::= ',' <Commas> |                         

! reference allows passing built in type (i32, r32, etc) by reference
<Optional Reference>     ::= '&' | 

! ===================================================================
! Statements
! i32 a b c = 1 2 (3+4)
! for i in 1..10
! for i in a..b by 2
! for item in array
! if a 
!    clause1
! else
!    clause2
! a = b + c
! r g b = 1.0 2.0 3.0
! while ! done
!    if a = 5
!       break
! ===================================================================
! zero or more statements
<Statements> ::= <Statement> <Statements> |

<Statement>   ::= <Variable Definition> <EOLs>
                | <Assign Statement>    <EOLs>
                | <If Statement>
                | <For Statement>       
                | 'while' <Expression>  <EOLs> <Block>
                | <Function Call>       <EOLs>
                | <Jump Statement>      <EOLs>

! assign some values to some variables
! a = 1
! a,b,c = 1,2,3
! bob[10].item[1],b += 0, 1
<Assign Statement>  ::= <Assign List> <Assign Operator> <Expression List>
<Assign Operator>   ::= '='
                     |  '+='
                     |  '-='
                     |  '*='
                     |  '/='
                     |  '^='
                     |  '&='
                     |  '|='
                     |  '%='
                     |  '>>='
                     |  '<<='
                     |  '>>>='
                     |  '<<<='

! a list of one or more things to assign expressions to
<Assign List> ::= <Assign Item> ',' <Assign List> | <Assign Item>
              
! one or more items to assign to
! also handle things like bob[10].field.array[12,23]
! how about a[0][3], example, char in a string from array?
! form is ID ('[' list '])
<Assign Item> ::= ID 
                | ID '.' <Assign Item>
                | ID '[' <Expression List> ']' 
                | ID '[' <Expression List> ']' '.' <Assign Item>

! if statement follows C somewhat
<If Statement> ::= 'if' <Expression> <EOLs> <Block>
                 | 'if' <Expression> <EOLS> <Then St> 'else' <EOLs> <Block>
                 | 'if' <Expression> <EOLs> <Then St> 'else' <If Statement>
<Then St> ::=  <Block> ! this trick makes the grammar LALR

! function call 
<Function Call> ::= ID '(' <Expression List> ')'
               
! jump around
<Jump Statement>  ::= break 
                    | continue 
                    | return <Expression List>

!<For Statement> ::= for ID '=' <Expression> 'to' <Expression>  <EOLs> <Block>
!                  | for ID '=' <Expression> 'to' <Expression> 'by' <Expression> <EOLs> <Block>
!                  | for ID 'in' <Assign Item> <EOLs> <Block>

<For Statement> ::= for ID in <Expression List> <EOLs> <Block>

! a block is an indented collection of statements
<Block>     ::= INDENT <Statements> DEDENT
             

! ===================================================================
! Here begins C style levels of operator precedence.
! An expression evaluates to a Value (a string, int, real, char, bool, user type)
! non left recursive type patterned after Mouse PEG parser http://www.romanredz.se/Mouse/C.peg
! ===================================================================

!! 0 or more expressions, used in assignments and function lists
!<Expression List> ::= <Expression> ',' <Expression List> | <Expression> | 
!
!PrimaryExpression
!    = Identifier
!    / Constant
!    / StringLiteral
!    / LPAR Expression RPAR
!    ;
!
!PostfixExpression
!    = ( PrimaryExpression
!      / LPAR TypeName RPAR LWING InitializerList COMMA? RWING
!      )
!      ( LBRK Expression RBRK
!      / LPAR ArgumentExpressionList? RPAR
!      / DOT Identifier
!      / PTR Identifier
!      / INC
!      / DEC
!      )*
!    ;
!
!ArgumentExpressionList
!    = AssignmentExpression (COMMA AssignmentExpression)*
!    ;
!
!UnaryExpression
!    = PostfixExpression
!    / INC UnaryExpression
!    / DEC UnaryExpression
!    / UnaryOperator CastExpression
!    / SIZEOF (UnaryExpression / LPAR TypeName RPAR )
!    ;
!
!UnaryOperator
!    = AND
!    / STAR
!    / PLUS
!    / MINUS
!    / TILDA
!    / BANG
!    ;
!
!CastExpression
!    = (LPAR TypeName RPAR)* UnaryExpression
!    ;
!
!MultiplicativeExpression
!    = CastExpression ((STAR / DIV / MOD) CastExpression)*
!    ;
!
!AdditiveExpression
!    = MultiplicativeExpression ((PLUS / MINUS) MultiplicativeExpression)*
!    ;
!
!ShiftExpression
!    = AdditiveExpression ((LEFT / RIGHT) AdditiveExpression)*
!    ;
!
!RelationalExpression
!    = ShiftExpression ((LE / GE / LT / GT) ShiftExpression)*
!    ;
!
!EqualityExpression
!    = RelationalExpression ((EQUEQU / BANGEQU) RelationalExpression)*
!    ;
!
!ANDExpression
!    = EqualityExpression (AND EqualityExpression)*
!    ;
!
!ExclusiveORExpression
!    = ANDExpression (HAT ANDExpression)*
!    ;
!
!InclusiveORExpression
!    = ExclusiveORExpression (OR ExclusiveORExpression)*
!    ;
!
!LogicalANDExpression
!    = InclusiveORExpression (ANDAND InclusiveORExpression)*
!    ;
!
!LogicalORExpression
!    = LogicalANDExpression (OROR LogicalANDExpression)*
!    ;
!
!ConditionalExpression
!    = LogicalORExpression (QUERY Expression COLON LogicalORExpression)*
!    ;
!
!AssignmentExpression
!    = UnaryExpression AssignmentOperator AssignmentExpression
!    / ConditionalExpression
!    ;
!
!AssignmentOperator
!    = EQU
!    / STAREQU
!    / DIVEQU
!    / MODEQU
!    / PLUSEQU
!    / MINUSEQU
!    / LEFTEQU
!    / RIGHTEQU
!    / ANDEQU
!    / HATEQU
!    / OREQU
!    ;
!
!Expression
!    = AssignmentExpression (COMMA AssignmentExpression)*
!    ;
!
!ConstantExpression
!    = ConditionalExpression
!    ;


! ===================================================================
! Here begins C style levels of operator precedence.
! An expression evaluates to a Value (a string, int, real, char, bool, user type)
! ===================================================================
! todo - fix all left recursion
! 0 or more expressions, used in assignments and function lists
<Expression List> ::= <Expression> ',' <Expression List> | <Expression> | 

<Expression> ::= <Op Or>

<Op Or>      ::= <Op Or> '||' <Op And> 
               | <Op And>

<Op And>     ::= <Op And> '&&' <Op BinOR>
               | <Op BinOR>

<Op BinOR>   ::= <Op BinOr> '|' <Op BinXOR>
               | <Op BinXOR>

<Op BinXOR>  ::= <Op BinXOR> '^' <Op BinAND>
               | <Op BinAND>

<Op BinAND>  ::= <Op BinAND> '&' <Op Equate>
               | <Op Equate>

<Op Equate>  ::= <Op Equate> '==' <Op Compare>
               | <Op Equate> '!=' <Op Compare>
               | <Op Compare>

<Op Compare> ::= <Op Compare> '<'  <Op Shift>
               | <Op Compare> '>'  <Op Shift>
               | <Op Compare> '<=' <Op Shift>
               | <Op Compare> '>=' <Op Shift>
               | <Op Shift>

<Op Shift>   ::= <Op Shift> '<<' <Op Rotate> 
               | <Op Shift> '>>' <Op Rotate>
               | <Op Rotate>

<Op Rotate>  ::= <Op Rotate> '<<<' <Op Add> ! rotate left
               | <Op Rotate> '>>>' <Op Add> ! rotate right
               | <Op Add>

<Op Add>     ::= <Op Add> '+' <Op Mult>
               | <Op Add> '-' <Op Mult>
               | <Op Mult>

<Op Mult>    ::= <Op Mult> '*' <Op Unary>
               | <Op Mult> '/' <Op Unary>
               | <Op Mult> '%' <Op Unary>
               | <Op Unary>

<Op Unary>   ::= '!'    <Op Unary> ! logical not
               | '~'    <Op Unary> ! bitwise invert  
               | '-'    <Op Unary> ! negate
               | '+'    <Op Unary> ! positive, for int, float
               | '++'   <Op Unary>
               | '--'   <Op Unary>
               | <Op Pointer> '++'
               | <Op Pointer> '--'
!               | '(' <Type> ')' <Op Unary>   !CAST - causes reduce-reduce conflict
               | <Op Pointer>

<Op Pointer> ::= <Op Pointer> '.' <Value>               
               | <Op Pointer> '[' <Expression List> ']'
               | <Value>

<Value>      ::= BinLiteral
               | HexLiteral
               | DecLiteral  
               | StringLiteral
               | CharLiteral
               | FloatLiteral
               | <Bool Literal>
               | <Function Call>              
               | ID                           ! identifier
               | '(' <Expression> ')'         ! sub expression
               
<Bool Literal> ::= true | false
                
! todo - add multiple return items
! todo - add module/namespace (last module "name" prefixes all exports/imports?)
! END OF GRAMMAR
