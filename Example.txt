// example code converted from HypnoLight visualizations

// OLD HEADERS MOVED TO BOTTOM
import "HypnoLight.clsc" // CLSC extensions


type MorseCodeState
    i32 shift      // integer shift
    Particle hue
    Particle delta // partial shift, counts 0-1 with wrap
    string message

// "All Hail Hypnocube "
const string hailHypnocubeMessage = "101110001011101010001011101010000000101010100010111000101000101110101000000010101010001110101110111000101110111010001110100011101110111000111010111010001010111000111010101000100000"

// "egg Egg EGG EGG Egg egg "
const string easterEggMessage = "1000111011101000111011101000000010001110111010001110111010000000100011101110100011101110100000001000111011101000111011101000000010001110111010001110111010000000100011101110100011101110100000"

// "I feel very very sleepy "
const string dimMessage = "101000000010101110100010001000101110101000000010101011100010001011101000111010111011100000001010101110001000101110100011101011101110000000101010001011101010001000100010111011101000111010111011100000"

// "ghouls and goblins and ghosts and "
const string halloweenMessage = "11101110100010101010001110111011100010101110001011101010001010100000001011100011101000111010100000001110111010001110111011100011101010100010111010100010100011101000101010000000101110001110100011101010000000111011101000101010100011101110111000101010001110001010100000001011100011101000111010100000"

// "copyright hypnocube two thousand fifteen   "
const string copyrightMessage = "1110101110100011101110111000101110111010001110101110111000101110100010100011101110100010101010001110000000101010100011101011101110001011101110100011101000111011101110001110101110100010101110001110101010001000000011100010111011100011101110111000000011100010101010001110111011100010101110001010100010111000111010001110101000000010101110100010100010101110100011100010001000111010000000000000"

[Vis "Morse Code"] // attribute
void MorseCode(Visualization vis)
    MorseCodeState state
    LoadData(vis,state)
    
    i32 i,j
    if vis.frame == 0
        // initialize
        state.shift = 0
        i32 pixPerSecond = 5
        ParticleInit(state.delta,0,0,pixPerSecond,1,1,vis.fps,DIRECTION_POSITIVE)
        // pick this to keep colors matched to moving blocks
        ParticleInit(state.hue,0,HSLMAX,HSLMAX+1,10,10,vis.fps,DIRECTION_POSITIVE)

        // select a message
        i32 active = GetActiveTheme()
        if active == THEME_EASTER
            state.message = easterEggMessage
        else if active == THEME_HALLOWEEN
            state.message = halloweenMessage
        else if active == THEME_CYAN
            state.message = copyrightMessage
        else if active == THEME_WHITE
            state.message = dimMessage
        else //default
            state.message = hailHypnocubeMessage
        // end init
  

    int slen = state.message.length
    if ParticleUpdate(state.delta,0.0,1.0,ENDPOINT_WRAP)
        state.shift = PositiveMod(state.shift+1,slen)

    ParticleUpdate(state.hue,0.0,1.0,ENDPOINT_WRAP)

    // update and draw
    for i in 0..NUM_PIXELS-1
        if mc[PositiveMod(i+state.shift,slen)]=='1'
            r32 hue = state.hue.value + (r32)i/(r32)NUM_PIXELS
            RGBColor color = HSLToRGB(HSLColor(hue,1.0,0.5))
            SetPixel(i color)
        else
            SetPixel(i,RGBColor(0.0,0.0,0.0))
    SaveData(vis,state)
// end MorseCode


// compute channel color, given left, above, right
// and state = 0 for off or 1 for on.
// must have low red bit set as state
i32 CellC(i32 left, i32 center, i32 right, i32 state)
    if state == 0
        //v = min(min(left,center),right)
        //v &= (~1)
        return 0
    else
        //v = max(max(left,center),right)
        //v |= 1
        return 255

type Cellular1DState
    i32 rule     // Wolfram labeling 0-255
    i32 bits[NUM_PIXELS] // 0 or 1 
    Particle hue

[Vis "Cellular1D"] // attribute
void Cellular1D(Visualization vis)
    Cellular1DState state

    // load settings
    VisLoadObject(vis,state)

    int32_t i,j,r,g,b;
    if vis.frame == 0
        // initialize
        ParticleInit(&state.hue,0.0,1.0,1.0,4.0,5.0,vis.fps,DIRECTION_RANDOM)
        // set random state
        for i in 0..NUM_PIXELS-1
            if rand8() > 127
                state.bits[i] = 0
            else
                state.bits[i] = 1

        vis.fps = 10
        // rules that are nice: 30,90,110
        i32 rules[4] = {30,90,110}

        state.rule = rules[randUniform(3)]
        //Print("1D rule {state.rule}"ENDLINE)


    // update and draw
    ParticleUpdate(state.hue,0.0,1.0,ENDPOINT_WRAP)

    // todo - this algorithm overwrites info needed for next pass - correct....
    for i in 0..NUM_PIXELS-1
        i32 center = state.bits[i]
        i32 left = 0, right = 0
        // get right
        if i+1<NUM_PIXELS
            right = state.bits[i+1]
        else
            // 0th pixel for wrapping around
            right = state.bits[0]
        if 0 < i
            left  = state.bits[i-1]
        else
            left  = state.bits[NUM_PIXELS-1]

        // combine bits to get index of new bit
        i32 b = (left<<2) | (center<<1) | (right)
        // bit to set 0 or 1
        i32 bit = (state.rule & (1<<b))>>b 
        
        // draw and set state
        state.bits[i] = bit
        if bit == 0
            SetPixel(i,HSLColor(state.hue.value,1.0,0.5))
        else
            SetPixel(i,HSLColor(state.hue.value,1.0,0.9))

        // shift
        left = center
        center = right

    // save settings
    VisSaveObject(vis,state)
// end Cellular1D


#if 1
i32 RandomMove(i32 c)
    int32_t d = rand8()&7
    int s = randUniform(3)
    if (s == 0)
        c-=d
    else if (s == 1)
        c+=d
    c = Clamp(c,0,255)
    return c

[Vis "Random Walker"]
void RandomWalker(Visualization vis)
    int32_t i,j;
    int32_t r,g,b;
    if (vis->frame == 0)
    { // initialize
        Fill(255,255,255);
        for (i = 0; i < NUM_PIXELS; ++i)
        {
            r = rand8();
            g = rand8();
            b = rand8();
            SetPixel(i,r,g,b);
        }
    }

    int bound = 32;
    for (i = 0; i < NUM_PIXELS; ++i)
    {
        GetPixel(i,&r,&g,&b);
        r = RandomMove(r);
        g = RandomMove(g);
        b = RandomMove(b);
        if (r+g+b<bound || 255-bound < r+g+b)
        {
            r = rand8();
            g = rand8();
            b = rand8();
        }
        SetPixel(i,r,g,b);

        
    }


typedef struct
{
    int32_t position; // pixel position
    Particle_t decay; // counts 1 down to 0
} Twinkle_t;

#define NUM_TWINKLES 20
typedef struct
{
    Particle_t hue;
    Twinkle_t twinkles[NUM_TWINKLES];
} TwinkleState;

// start a twinkle if there is one available
static void AddTwinkle(int32_t position, Twinkle_t * twinkles, int count, int fps)
{
    int32_t i;
    for (i = 0; i < count; ++i)
    {
        if (twinkles[i].decay.value == 0)
        { // add one here
            // 1/5 to 1/10 sec
            int rate = randMod2(5,10);
            ParticleInit(&twinkles[i].decay,1,1, rate, 1,1,fps,DIRECTION_NEGATIVE);
            twinkles[i].position = position;
            return;
        }
    }
}

void Twinkle(Visualization * vis)
{
    TwinkleState state;

    // load settings
    VisLoadObject(vis,&state,sizeof(state));

    int32_t i,j;
    if (vis->frame == 0)
    { // initialize
        ParticleInit(&state.hue, 0, HSLMAX, HSLMAX, 17, 27, vis->fps, DIRECTION_RANDOM);
        for (i =0; i < NUM_TWINKLES; ++i)
            state.twinkles[i].decay.value = 0; // marks as available
    }

    // update and draw
    ParticleUpdate(&state.hue,0,HSLMAX,ENDPOINT_WRAP);
    int32_t hue = FixedPointToInteger(state.hue.value);
    
    for (i = 0; i < NUM_PIXELS; ++i)
    {
        int32_t sat,light,r,g,b;
        sat = HSLMAX;
        light = HSLMAX/2;
#if 1
        if (rand8()<2)
            AddTwinkle(i, state.twinkles, NUM_TWINKLES, vis->fps);

        // apply all twinkles
        FixedPoint a = 0;
        for (j = 0; j < NUM_TWINKLES; ++j)
        {
            if (state.twinkles[j].position == i)
                a = max(a,state.twinkles[j].decay.value);
        }

        light += FixedPointToInteger(a*HSLMAX/2);

#else
        if (rand8()<2)
        {
            int32_t del = HSLMAX-light;
            del = randMod2(del/2,del);
            if (rand8()<127)
                light -= del;
            else
                light += del;
            //hue = HSLMAX/2+hue;
        }
        else if (rand8()<10)
        {
            //sat = 3*HSLMAX/4;
        }
#endif
        HSLToRGB(hue,sat,light,&r,&g,&b);
        SetPixel(i,r,g,b);
    }

    // update twinkles
    for (i = 0; i < NUM_TWINKLES; ++i)
        ParticleUpdate(&state.twinkles[i].decay,0,1,ENDPOINT_CLAMP);

    // save settings
    VisSaveObject(vis,&state,sizeof(state));
}

#undef NUM_TWINKLES

// encoded copyright string, each char has bits rotated
// several in code, each named rotateX where X is the number of bit shifts
static const uint8_t rotate3[] = 
{104, 237, 14, 47, 78, 45, 236, 13, 142, 4, 9, 47, 14, 205, 237, 108,
174, 76, 172, 4, 137, 137, 104, 4, 70, 6, 38, 166, 0};


typedef struct
{
    Particle_t hue;
    FixedPoint periods;
} HueFlowState;

void HueFlow(Visualization * vis)
{
    HueFlowState state;

    // load settings
    VisLoadObject(vis,&state,sizeof(state));

    int32_t i,j;
    if (vis->frame == 0)
    { // initialize
        ParticleInit(&state.hue,0,HSLMAX,HSLMAX,4,5,vis->fps,DIRECTION_RANDOM);
        state.periods = FixedPoint(1)/8;
    }


    // update and draw
    ParticleUpdate(&state.hue,0,HSLMAX,ENDPOINT_WRAP);

    for (i = 0 ; i < NUM_PIXELS; ++i)
    {
        int32_t d = abs(i-NUM_PIXELS/2); // dist from center
        FixedPoint v = FixedPoint(d)/(NUM_PIXELS/2); // in 0-1 fixed point
        FixedPoint s = Sin(FixedPointMultiply(v,state.periods))*HSLMAX;
        int32_t hue = FixedPointToInteger(state.hue.value + s);
        hue = PositiveMod(hue,HSLMAX);
        int32_t r,g,b;
        HSLToRGB(hue,HSLMAX,HSLMAX/2,&r,&g,&b);
        SetPixel(i,r,g,b);
    }

    // save settings
    VisSaveObject(vis,&state,sizeof(state));
}


typedef struct
{
    Particle_t mainBeat;   // counts 0-1, beats each time passes 1
    Particle_t secondBeat; // at each beat, counts 0-1, beats at 0 and 1
    Particle_t decay;      // counts 0-1, handles decay of the beat coloring
    Particle_t hue;        // current color
} HeartbeatState;

void Heartbeat(Visualization * vis)
{
    HeartbeatState state;

    // load settings
    VisLoadObject(vis,&state,sizeof(state));

    int32_t i,j;
    if (vis->frame == 0)
    { // initialize

        int32_t beatsPerMinute = randMod2(30,50);
        ParticleInit(&state.mainBeat, 0,0, beatsPerMinute,60,60, vis->fps, DIRECTION_POSITIVE);
        ParticleInit(&state.hue, 0,HSLMAX, HSLMAX, 15, 23, vis->fps, DIRECTION_RANDOM);
        state.decay.value = state.decay.delta = 0;
        state.secondBeat.value = state.secondBeat.delta = 0;

    }

    // update
    ParticleUpdate(&state.decay, 0, 1, ENDPOINT_CLAMP);
    ParticleUpdate(&state.hue, 0, HSLMAX+1, ENDPOINT_WRAP);

    bool startDecay = false;

    if (ParticleUpdate(&state.secondBeat, 0, 1, ENDPOINT_UNBOUNDED))
    {
        state.secondBeat.value = 5;
        state.secondBeat.delta = 0; // make stop triggering
        startDecay = true;
    }

    if (ParticleUpdate(&state.mainBeat, 0, 1, ENDPOINT_WRAP))
    { // start a beat
        // second beat in 1/4 sec away
        ParticleInit(&state.secondBeat, 0,0, 5,1,1, vis->fps, DIRECTION_POSITIVE);
        startDecay = true;
    }

    if (startDecay)
        // decay happens that quickly too
        ParticleInit(&state.decay, 1,1, 2, 1, 1, vis->fps, DIRECTION_NEGATIVE);

    // draw
    int32_t r,g,b, h, s, l;

    h = FixedPointToInteger(state.hue.value);

    s = HSLMAX;
    l = HSLMAX/2+FixedPointToInteger(state.decay.value*HSLMAX/2);

    s = HSLMAX/2+FixedPointToInteger(state.decay.value*HSLMAX/2);
    l = HSLMAX/2;

    HSLToRGB(h,s,l,&r,&g,&b);
    Fill(r,g,b);

    // save settings
    VisSaveObject(vis,&state,sizeof(state));
}

#if 1
typedef struct
{
    FixedPoint position;     // position in pixels
    FixedPoint oldPosition;  // prev position in pixels
    FixedPoint acceleration; // place to store per item acceleration
    Particle_t hue;
} SpringsState;

void Springs(Visualization * vis)
{
#define MAX_STATE (VIS_STATE_SIZE/sizeof(SpringsState))  // number of state entries
    SpringsState state[MAX_STATE];

    // load settings
    VisLoadObject(vis,state,sizeof(state));

    int32_t numBalls, temp;
    UNPACK2(vis->simpleState1,numBalls,5,temp,5);


    int32_t i,j;
    if (vis->frame == 0)
    { // initialize

        numBalls = MAX_STATE; // randMod2(3,4);

        numBalls = 10;

        for (i = 0; i < numBalls; ++i)
        {
            SpringsState * s = state+i;
            ParticleInit(&s->hue,0,HSLMAX,HSLMAX,10,13,vis->fps,DIRECTION_RANDOM);
            s->hue.value = FixedPoint(i*HSLMAX)/numBalls;
            s->hue.delta = FixedPoint(HSLMAX)/(5*vis->fps);
            s->position = FixedPoint(i*NUM_PIXELS)/numBalls;
            s->oldPosition = s->position;
        }

        // give middle one some velocity
        state[numBalls/2].position += FixedPoint(15)/vis->fps; // pixels per frame
        state[numBalls/2].hue.value = FixedPoint(HSLMAX/2);

    }
#if 1
    // compute forces on each ball, and from that, velocity changes
    FixedPoint delta = FixedPoint(NUM_PIXELS)/numBalls; // zero force distance between balls
    FixedPoint scale = FixedPoint(1)/1; // spring constant divided by ball mass
    for (i = 0; i < numBalls; ++i)
    {
        SpringsState * s = state+i;
        FixedPoint force = 0;

        // right and left distances
        FixedPoint dR, dL;
        if (0 != i)
            dL = s->position - state[i-1].position;
        else // wraps
            dL = s->position - state[numBalls-1].position + FixedPoint(NUM_PIXELS);

        if (numBalls-1 != i)
            dR = state[i+1].position - s->position;
        else // wraps
            dR = state[0].position - s->position + FixedPoint(NUM_PIXELS);

        FixedPoint a = FixedPointMultiply(dR-delta -(dL-delta), scale); // acceleration, pixels/second

        s->acceleration = a;
    }
    // now update all positions
    //Print("Spring :");
    for (i = 0; i < numBalls; ++i)
    {
    //    i = numBalls/2;
        SpringsState * s = state+i;

        // Verlet integration:
        FixedPoint dt  = FixedPoint(1)/vis->fps;
        FixedPoint dt2 = FixedPointMultiply(dt,dt);
        FixedPoint newPosition = 2*s->position - s->oldPosition + FixedPointMultiply(dt2,s->acceleration);

        s->oldPosition = s->position;
        s->position = newPosition;
        //Print("%d ", s->position);
    }
    //Print(ENDLINE);
#endif
    // draw
    //Fill(0,0,0);
    Fade(0,0,0,5);
    for (j = 0; j < numBalls; ++j)
    {
        SpringsState * s = state+j;
        int32_t r,g,b;
        HSLToRGB(FixedPointToInteger(s->hue.value),HSLMAX,HSLMAX/2,&r,&g,&b);

        int32_t pos = FixedPointToInteger(s->position);
        pos = PositiveMod(pos,NUM_PIXELS);

        SetPixel(pos,r,g,b);
    }

#undef MAX_STATE // clean up

    PACK2(vis->simpleState1,numBalls,5,temp,5);

    // save settings
    VisSaveObject(vis,state,sizeof(state));
}
#endif


typedef struct
{
    FixedPoint length1, length2; // different pendulum lengths
    FixedPoint k; // scaling constant
    FixedPoint baseHue;
} NewtonHueState;

void NewtonHue(Visualization * vis)
{
    NewtonHueState state;

    // load settings
    VisLoadObject(vis,&state,sizeof(state));

    int32_t i,j;
    if (vis->frame == 0)
    { // initialize
      // each led has different period, colors hue
      // pick pendulum lengths L0 < L1, and take period
      // for led # x (x=0,1,..,N-1) to be
      // k*sqrt(L0+(L1-L0)x/N-1)) for some const k

        state.length1 = randMod2(FixedPoint(3),FixedPoint(8));
        state.length2 = state.length1 + randMod2(FixedPoint(4),FixedPoint(8));
        if (rand8()>127)
        { // swap order
            FixedPoint t = state.length1;
            state.length1 = state.length2;
            state.length2 = t;
        }
        state.k = randMod2(FixedPoint(1)/16,FixedPoint(3)/16)/vis->fps;
        state.k /= 10;
        state.baseHue = randMod(FixedPoint(HSLMAX));
    }



    // update and draw
    for (i = 0; i < NUM_PIXELS; ++i)
    {
        int32_t r,g,b;
        int dist = abs(i-NUM_PIXELS/2);
        FixedPoint p =  LinearInterpolate(state.length1,state.length2, dist, NUM_PIXELS/2-1);
        p = FixedPointSqrt(p);
        p = FixedPointMultiply(p,state.k);

        int32_t hue = FixedPointToInteger((HSLMAX+1)*Cos(vis->frame*p)+state.baseHue);
        HSLToRGB(hue,HSLMAX,HSLMAX/2,&r,&g,&b);

        SetPixel(i,r,g,b);
    }


    // save settings
    VisSaveObject(vis,&state,sizeof(state));
}


typedef struct
{
    // samples of varying frequencies
    // 1 of low freq, 2 of next freq, ..., 2^t of highest freq
    // total number then 2^(t+1)-1
    Particle_t samples[31];
    Particle_t shift;
} FireState;

// compute RGB for a nice fire
// given value in [0,1] compute fire palette
// RGB in [0,255]
void GetFireRGB(FixedPoint value, int32_t * red, int32_t * green, int32_t * blue)
{
    *red = FixedPointToInteger(value*255);
    *green = 0;
    *blue = 0;
    if (value > FixedPoint(55)/100) // green kicks in here
        *green = LinearInterpolate(0,255,value - FixedPoint(55)/100,FixedPoint(45)/100);
    if (value > FixedPoint(80)/100) // blue here
        *blue = LinearInterpolate(0,255,value - FixedPoint(80)/100,FixedPoint(20)/100);
}


// fire based on adding triangular frequency - fractional brownian motion?
void Fire(Visualization * vis)
{
    FireState state;

    // load settings
    VisLoadObject(vis,&state,sizeof(state));

    uint8_t permutation,temp;
    UNPACK2(vis->simpleState1,permutation,4,temp,1);

    int maxLevel   = 4;  // levels 0-4
    int numSamples  = (1<<(maxLevel+1))-1; // from each level: 1+2+4+8+16 = 31

    int32_t i,j,level,sublevel;
    if (vis->frame == 0)
    { // initialize
        i=0;
        for (level = 0; level <= maxLevel; ++ level)
        {
            for (sublevel = 0; sublevel < (1<<level); ++sublevel)
            {
                int32_t secsToCycle = randMod2(75,125);
                int32_t timesToCycle = randMod2(75*(1<<level),125*(1<<level))/3;
                ParticleInit(&state.samples[i],0,1,timesToCycle,secsToCycle,secsToCycle,vis->fps,DIRECTION_RANDOM);
                ++i;
            }
        }
        ParticleInit(&state.shift,0,NUM_PIXELS,NUM_PIXELS,22,37,vis->fps,DIRECTION_RANDOM);
        //permutation  = randUniform(6);
        permutation = 0; // others ugly
    }

    // update
    for (i = 0; i < numSamples; ++i)
        ParticleUpdate(&state.samples[i],0,1,ENDPOINT_BOUNCE);

    ParticleUpdate(&state.shift,0,NUM_PIXELS,ENDPOINT_WRAP);

    int32_t shift = FixedPointToInteger(state.shift.value);

    // draw
    for (i = 0; i < NUM_PIXELS; ++i)
    {
        FixedPoint total = 0;

        FixedPoint scale = FixedPoint(1); // amount next level contributes
        
        for (level = 0; level <= maxLevel; ++ level)
        {
            // sublevel is index to read in this level
            sublevel = (i*(1<<level))/NUM_PIXELS; // scales i/NUM onto 2^level

            // excess is amount into sublevel sample, normalized into [0,2)
            FixedPoint excess = RoundDiv32(2*FixedPoint((i*(1<<level))-NUM_PIXELS*sublevel),NUM_PIXELS);

            // half up, half down, reflect
            if (excess >= FixedPoint(1))
                excess = FixedPoint(2) - excess;

            int sampleIndex = ((1<<level)-1)+sublevel;

            //Print("Fire index %d, level %d sublevel %d, sampleIndex %d, excess %d"ENDLINE,i,level,sublevel, sampleIndex,excess);


            FixedPoint sampleHeight = state.samples[sampleIndex].value;

            scale /= 2;
            total += FixedPointMultiply(FixedPointMultiply(scale,excess), sampleHeight);
        }

        //// total is short from 1 by scale, so scale total into [0,1]:
        //total = FixedPointDivide(total,FixedPoint(1)-scale);

        //total = Clamp(total*2,0,FixedPoint(1));

        // make brighter by expected value, and clamp
        // for max level L , expected value (2^(L+1)-1)/2^(L+2)
        total *= 1<<(maxLevel+2);
        total = RoundDiv32(total,(1<<(maxLevel+1))-1);
        total = Clamp(total,0,FixedPoint(1));

        //Print("Fire index %d -> total %d"ENDLINE,i,total);
        
        // color based on total

        int32_t r,g,b;

        // see palette
        // total = RoundDiv32(FixedPoint(i),NUM_PIXELS-1);

        // compute RGB
        GetFireRGB(total,&r,&g,&b);

        Permute3(permutation,&r,&g,&b);

        int pos = PositiveMod(i+shift,NUM_PIXELS);
        SetPixel(pos,r,g,b);

    }

    // save settings
    VisSaveObject(vis,&state,sizeof(state));
    PACK2(vis->simpleState1,permutation,4,temp,1);
}


typedef struct
{
    int32_t hue;
    DirectionMode_t hueDirection;
    FixedPoint position;   // pixel position
    FixedPoint speed;      // pixels per frame
    bool lowToHigh;        // direction to draw
} UpAndDownState;

void UpAndDown(Visualization * vis)
{
    UpAndDownState state;

    // load settings
    VisLoadObject(vis,&state,sizeof(state));

    int32_t r,g,b;
    if (vis->frame == 0)
    { // initialize

        state.speed = randMod2(FixedPoint(10),FixedPoint(40))/(vis->fps);
        state.lowToHigh = rand8()>127?true:false;
        state.hue = randMod(HSLMAX+1);
        state.hueDirection = rand8()>127?DIRECTION_POSITIVE:DIRECTION_NEGATIVE;
    }

    // update and draw
    int32_t cutoff = FixedPointToInteger(state.position);
    int32_t j;

    HSLToRGB(state.hue,HSLMAX,HSLMAX/2,&r,&g,&b);

    if (state.lowToHigh)
    {
        for (j = 0; j <= cutoff; ++j)
            SetPixel(j,r,g,b);
        state.position += state.speed;
    }
    else
    {
        for (j = NUM_PIXELS; j >= cutoff; --j)
            SetPixel(j,r,g,b);
        state.position -= state.speed;
    }

    if (state.position < 0 || state.position > FixedPoint(NUM_PIXELS-1))
    { // reverse
        state.speed = randMod2(FixedPoint(10),FixedPoint(40))/(vis->fps);
        state.lowToHigh = !state.lowToHigh;
        if (state.position < 0)
            state.position = 0;
        else
            state.position = FixedPoint(NUM_PIXELS-1);
        state.hue = NextHue(state.hue, 400, 800, state.hueDirection);

    }
    
    // save settings
    VisSaveObject(vis,&state,sizeof(state));
}


typedef struct
{
    Particle_t hue;
    Particle_t position;
    bool active;
} ShooterState;

void Shooter(Visualization * vis)
{
#define MAX_STATE 4  // number of state entries
    ShooterState state[MAX_STATE];

    // load settings
    VisLoadObject(vis,state,sizeof(state));

    int i;
    if (vis->frame == 0)
    { // initialize

        // set states
        int top = randMod2(1,MAX_STATE);
        int dir = rand8()>127?DIRECTION_POSITIVE:DIRECTION_NEGATIVE;
        for (i = 0; i < MAX_STATE; ++i)
        {
            ParticleInit(
                &(state[i].position),        // the particle
                    0,    // min random position
                    NUM_PIXELS,    // max random position
                    75,    // desired change in time interval
                    3,     // min time to change in seconds
                    5,     // max time to change in seconds
                    vis->fps,              // frames per second update will be called
                    dir // DIRECTION_NEGATIVE, DIRECTION_POSITIVE, or DIRECTION_RANDOM
                );

            ParticleInit(
                &(state[i].hue),        // the particle
                    0,    // min random position
                    HSLMAX+1,    // max random position
                    HSLMAX,    // desired change in time interval
                    5,     // min time to change in seconds
                    15,     // max time to change in seconds
                    vis->fps,              // frames per second update will be called
                    DIRECTION_RANDOM // DIRECTION_NEGATIVE, DIRECTION_POSITIVE, or DIRECTION_RANDOM
                );
            state[i].active = i<top?true:false;
        }

    }

    // update and draw
    Fade(0,0,0,15);
    int32_t j;
    for (j = 0; j < MAX_STATE; ++j)
    {
        ShooterState * s = state+j;
        ParticleUpdate(&(s->position),0,NUM_PIXELS,ENDPOINT_WRAP);
        ParticleUpdate(&(s->hue),0,HSLMAX+1,ENDPOINT_WRAP);

        int32_t r,g,b;

        int k = FixedPointToInteger(s->position.value);
        HSLToRGB(FixedPointToInteger(s->hue.value),HSLMAX,HSLMAX/2,&r,&g,&b);

        SetPixel(k,r,g,b);
    }

#undef MAX_STATE // clean up

    // save settings
    VisSaveObject(vis,state,sizeof(state));
}



typedef struct
{
    uint16_t runLengths[NUM_PIXELS/2];
    int32_t runCount;
    Particle_t hue1, hue2; // 2 hue colors
} CheckerboardState;

void Checkerboard(Visualization * vis)
{
    CheckerboardState state;

    // load settings
    VisLoadObject(vis,&state,sizeof(state));

    int i;
    if (vis->frame == 0)
    { // initialize
        // run count and lengths
        state.runCount = GetRunsCount(
                state.runLengths, // run lengths, must be enough to hold possible answers
                -1,    // min number of runs, or -1 for don't care
                sizeof(state.runLengths)/sizeof(uint16_t),   // max number of runs, or -1 for don't care
                 4,    // min run length, -1 for don't care
                -1,    // max run length, -1 for don't care
                RUN(2)|RUN(4)|RUN(6)|RUN(8),   // bit n=0,1,..,31 set if (n+1) desired to be a # of runs
                true,   // allow even # of run counts
                false,  // allow odd number of runs
                false   // require exact divisors
                );

        ParticleInit(&(state.hue1),0,HSLMAX,HSLMAX,4,12,vis->fps,DIRECTION_RANDOM);
        ParticleInit(&(state.hue2),0,HSLMAX,HSLMAX,4,12,vis->fps,DIRECTION_RANDOM);

    }

    // update and draw
    ParticleUpdate(&(state.hue1),0,HSLMAX,ENDPOINT_WRAP);
    ParticleUpdate(&(state.hue2),0,HSLMAX,ENDPOINT_WRAP);

    for (i = 0; i < NUM_PIXELS; ++i)
    {
        int runIndex = GetRunIndex(i,state.runLengths, state.runCount, NULL);
        int32_t h = FixedPointToInteger(runIndex&1?state.hue1.value:state.hue2.value);
        int32_t r,g,b;
        HSLToRGB(h,HSLMAX,HSLMAX/2,&r,&g,&b);
        SetPixel(i,r,g,b);
    }

    // save settings
    VisSaveObject(vis,&state,sizeof(state));
}



#define ROW_HEIGHT 25
typedef struct
{
    int16_t indices[ROW_HEIGHT]; // index to the RGB, then count, for current row color
    int16_t counter[ROW_HEIGHT]; // how many times to repeat this before advancing
    const uint8_t * data;        // pointer to the data
} SmileySpinnerState;

// load initial state
static void InitImageState(SmileySpinnerState*state,const uint8_t * imgData, const uint16_t * rowStarts)
{
    int i;
    for (i = 0; i < ROW_HEIGHT; ++i)
    {
        state->indices[i] = rowStarts[i]; // offset into data for this row
        const uint8_t * p = imgData + rowStarts[i];
        p+=3; // skip RGB
        state->counter[i] = (*p)+(*(p+1))*256; // count this many
    }
    state->data = imgData;

}


void SmileySpinner(Visualization * vis)
{
    SmileySpinnerState state;

    // load settings
    VisLoadObject(vis,&state,sizeof(SmileySpinnerState));

    if (vis->frame == 0)
    { // initialize
        vis->fps = 300; // these are fast. Want to show the whole image each second
    }

    // every so often, reload the image
    if ((vis->frame%300) == 0)
        InitImageState(&state,smileyData,smileyRowStarts);

    Fill(0,0,0);


    // update and draw
    int32_t j;
    for (j = 0; j < ROW_HEIGHT; ++j)
    {
        // get RGB
        int r,g,b;
        const uint8_t * p = state.data;
        p += state.indices[j];
        b = *p++;
        g = *p++;
        r = *p++;

        SetPixel(j,r,g,b);

        state.counter[j]--;
        if (state.counter[j] <= 0)
        {
            state.indices[j] += 5; // next RGB,count
            p+=5; // skip to counter
            state.counter[j] = (*p)+(*(p+1))*256; // count this many
        }
    }


    // save settings
    VisSaveObject(vis,&state,sizeof(SmileySpinnerState));
}

#undef ROW_HEIGHT


typedef struct
{
    Particle_t angle;      // used for position state
    Particle_t hue;        // main color

    FixedPoint shift;      // pixels shifted from 0 start
    FixedPoint radius;     // how many pixels to swing

    int periods;           // number of periods over the length of the strand
} BackAndForthState;

int32_t BackAndForthPixelMerge(int32_t src, int32_t dst)
{
    return max(src,dst);
}

// back and forth color waving
void BackAndForth(Visualization * vis)
{
#define MAX_STATE 3  // number of state entries
    BackAndForthState state[MAX_STATE];

    // load settings
    VisLoadObject(vis,state,sizeof(state));

    if (vis->frame == 0)
    { // initialize
        int32_t i;
        for (i = 0; i < MAX_STATE; ++i)
        {
            BackAndForthState * s = state+i;
            ParticleInit(&s->angle, 0,1, 1, 7, 16, vis->fps, DIRECTION_RANDOM);
            ParticleInit(&s->hue, 0,HSLMAX, HSLMAX, 4, 9, vis->fps, DIRECTION_RANDOM);
            s->shift  = randMod(FixedPoint(NUM_PIXELS));
            s->radius = randMod2(FixedPoint(NUM_PIXELS)/3,2*FixedPoint(NUM_PIXELS)/3);
            s->periods = randMod2(2,5);
        }
    }

    // update and draw
    int32_t j;
    Fill(0,0,0);
    for (j = 0; j < MAX_STATE; ++j)
    {
        BackAndForthState * s = state+j;
        
        ParticleUpdate(&s->angle,0,1,ENDPOINT_WRAP);
        ParticleUpdate(&s->hue,0,HSLMAX+1,ENDPOINT_WRAP);

        FixedPoint centerF = FixedPointMultiply(Sin(s->angle.value),s->radius)+s->shift;
        int32_t    centerI = FixedPointToInteger(centerF);
        FixedPoint excess  = centerF-FixedPoint(centerI);  // amount snipped
        FixedPoint dAngle  = FixedPointMultiply(excess,RoundDiv32(FixedPoint(1)*s->periods,NUM_PIXELS));



        int i;
        int hue = FixedPointToInteger(s->hue.value);
        for (i = 0; i < NUM_PIXELS; ++i)
        {
            FixedPoint lumUnit = Sin(RoundDiv32(-dAngle + i*FixedPoint(1)*s->periods,NUM_PIXELS));
            const FixedPoint lumMin = FixedPoint(HSLMAX)/16;
            const FixedPoint lumMax = FixedPoint(HSLMAX)/2;

            // scale between
            FixedPoint lumScaled = FixedPointMultiply(lumUnit, lumMax-lumMin) + lumMin;

            int32_t lum = FixedPointToInteger(lumScaled);
            int32_t r,g,b;
            HSLToRGB(hue,HSLMAX,lum,&r,&g,&b);

            int pos = PositiveMod(centerI + i,NUM_PIXELS);

            if (j == 0)
                MergePixel(pos,r,g/2,0,BackAndForthPixelMerge);
            if (j == 1)
                MergePixel(pos,0,g,b/2,BackAndForthPixelMerge);
            if (j == 2)
                MergePixel(pos,r/2,0,b,BackAndForthPixelMerge);
        }
    }

#undef MAX_STATE // clean up

    // save settings
    VisSaveObject(vis,state,sizeof(state));
}


typedef struct
{
    Particle_t angle;      // used for position state
    Particle_t position;   // position and pixels per frame speed
    bool       used;       // is this worm live?

} InchWormState;

void InchWorm(Visualization * vis)
{
#define MAX_STATE 4  // number of state entries
    InchWormState state[MAX_STATE];

    // load settings
    VisLoadObject(vis,state,sizeof(state));

    ColorBatch_t * cb = &(vis->colorBatch);

    if (vis->frame == 0)
    { // initialize
        int32_t i;
        int32_t top = randMod2(1,MAX_STATE+1);
        for (i = 0; i < MAX_STATE; ++i)
        {
            InchWormState * s = state+i;

            // position and speed
            ParticleInit(
                &(s->position),       // the particle
                    0,                // min random position
                    NUM_PIXELS-1,     // max random position
                    NUM_PIXELS,       // desired change in time interval
                    4,                // min time to change in seconds
                    9,                // max time to change in seconds
                    vis->fps,         // frames per second update will be called
                    DIRECTION_RANDOM  // DIRECTION_NEGATIVE, DIRECTION_POSITIVE, or DIRECTION_RANDOM
                );

            // movement state
            ParticleInit(
                &(s->angle),          // the particle
                    2,                // min random position
                    4,                // max random position
                    2,                // desired change in time interval
                    2,                // min time to change in seconds
                    4,                // max time to change in seconds
                    vis->fps,         // frames per second update will be called
                    DIRECTION_POSITIVE// DIRECTION_NEGATIVE, DIRECTION_POSITIVE, or DIRECTION_RANDOM
                );

            s->used = i<top?true:false;
        }

        ColorBatchInitSimple(
            cb,      // the color batch to initialize
            top,     // inclusive min number of distinct hues
            top,     // inclusive max number of distinct hues
            1,       // inclusive min number of shades per hue
            1,       // inclusive max number of shades per hue
            FixedPoint(1), // animation speed scaling, default to 1, larger is faster
            vis->fps // frames per second for updates, sets default animation rates
        );


    }

    // update and draw
    int32_t j;
    Fill(0,0,0);
    ColorBatchUpdate(cb);
    for (j = 0; j < MAX_STATE; ++j)
    {
        InchWormState * s = state+j;

        // during angle 0-1, move head and lengthen worm
        // during angle 1-2, shorten worm
        FixedPoint a = 0;
        if (s->angle.value < FixedPoint(1))
        {
            ParticleUpdate(&(s->position),0,NUM_PIXELS,ENDPOINT_WRAP);
            a = s->angle.value; // count from here down to zero when drawing
        }
        else
        { // angle in 1-2
            a = FixedPoint(2) - s->angle.value; // count from here down to zero when drawing
        }

        if (s->used)
        {
            // draw, backing up colors and positions
            FixedPoint p = s->position.value;
            int32_t hue;
            ColorBatchGetHSL(cb,j,0,&hue,NULL,NULL);
            int r,g,b;
            while (a >= 0)
            {
                int pos = PositiveMod(FixedPointToInteger(p),NUM_PIXELS);

                HSLToRGB(hue,HSLMAX,HSLMAX/2,&r,&g,&b);

                SetPixel(pos,r,g,b);

                a -= s->angle.delta;
                p -= s->position.delta;

                //h -= s->hue.;
                //if (h < 0) h += FixedPoint(HSLMAX+1);
                //if (h >= FixedPoint(HSLMAX+1)) h -= FixedPoint(HSLMAX+1);
            }
        }

        // worm movement state
        ParticleUpdate(&(s->angle),0,2,ENDPOINT_WRAP);
    }

#undef MAX_STATE // clean up

    // save settings
    VisSaveObject(vis,state,sizeof(state));
}

typedef struct {
    FixedPoint startPosition, endPosition, direction;
    int32_t length;
    int32_t frame,fps,maxFrame;
} Lightning_t;

void InitLightning(Lightning_t * lightning, FixedPoint position, FixedPoint direction, int32_t length, int32_t fps)
{
    lightning->startPosition = position;
    lightning->endPosition = position;
    lightning->direction = direction;
    lightning->frame = 0;
    lightning->maxFrame = randMod2(2*fps/3,7*fps/8);
    lightning->length=length;
    lightning->fps = fps;        
}

// return true while active, else false
bool UpdateLightning(Lightning_t * lightning)
{
    if (lightning->frame >= lightning->maxFrame)
        return false;
    lightning->frame++;
    if (abs(lightning->startPosition - lightning->endPosition) < FixedPoint(lightning->length))
        lightning->endPosition += lightning->direction;
    return true;
}
void DrawLightning(Lightning_t * lightning)
{
    int32_t i,r,g,b;
    int32_t baseLum = randMod2(HSLMAX/16,5*HSLMAX/5);

    int32_t start = FixedPointToInteger(lightning->startPosition);
    int32_t end   = FixedPointToInteger(lightning->endPosition);

    if (start > end)
    {
        // swap
        int32_t temp = start;
        start = end;
        end = temp;
    }

    for (i = start; i <= end; ++i)
    {
        int32_t lum = randMod2(-HSLMAX/5,HSLMAX/5)+baseLum;
        lum = Clamp(lum,0,HSLMAX);
        HSLToRGB(0,0,lum,&r,&g,&b);
        int32_t pos = PositiveMod(i,NUM_PIXELS);
        SetPixel(pos,r,g,b);
    }
}

typedef struct
{
    Particle_t hue;      // used for color, etc computations
    Particle_t position;

} CrashNodeState;

typedef struct
{
    CrashNodeState nodes[2];
    Lightning_t lightning[2];
    bool lightningActive[2];
} CrashesState;

// return true if the next lookahead updates will cause these to cross positions

static bool CrashOverlaps(const CrashNodeState * s1, const CrashNodeState * s2, int lookahead)
{
    FixedPoint p1a = s1->position.value;
    FixedPoint p1b = s1->position.value+s1->position.delta*lookahead;
    FixedPoint p2a = s2->position.value;
    FixedPoint p2b = s2->position.value+s2->position.delta*lookahead;

    if (p1a <= p2a && p1b >= p2b)
        return true;

    if (p1a >= p2a && p1b <= p2b)
        return true;

    return false; // no overlap
}

// two items bounce around, crash and reverse whenever they hit
void Crashes(Visualization * vis)
{
    CrashesState state;

    // load settings
    VisLoadObject(vis,&state,sizeof(state));


    int32_t i;
    if (vis->frame == 0)
    { // initialize
        for (i = 0 ; i < 2; ++i)
        {
            DirectionMode_t dir = (i&1)?DIRECTION_POSITIVE:DIRECTION_NEGATIVE;
            ParticleInit(&state.nodes[i].position,0,NUM_PIXELS,NUM_PIXELS,3,6,vis->fps,dir);
            ParticleInit(&state.nodes[i].hue,0,HSLMAX,HSLMAX,20,30,vis->fps,DIRECTION_RANDOM);
            state.lightningActive[i] = false;
        }
    }

    // update and draw
    Fill(0,0,0);

    // draw moving items, with fading
    int32_t j;
    for (j = 0; j < 2; ++j)
    {
        CrashNodeState * s = &state.nodes[j];
        int r,g,b;
#define FADE_LENGTH 5
        for (i = 0; i < FADE_LENGTH; ++i)
        {
            int32_t pos = FixedPointToInteger(s->position.value)-i*copysign(s->position.delta);
            pos = PositiveMod(pos,NUM_PIXELS);
            int32_t hue = FixedPointToInteger(s->hue.value);
            int32_t lum = (FADE_LENGTH-i)*HSLMAX/(2*FADE_LENGTH);
            HSLToRGB(hue,HSLMAX,lum,&r,&g,&b);
            SetPixel(pos,r,g,b);
        }
#undef FADE_LENGTH
        if (!state.lightningActive[0] && !state.lightningActive[1])
        {
            ParticleUpdate(&s->position,0,NUM_PIXELS,ENDPOINT_WRAP);
            ParticleUpdate(&s->hue,0,HSLMAX,ENDPOINT_WRAP);
        }
    }

    // draw lightning
    for (i = 0; i < 2; ++i)
    {
        if (state.lightningActive[i])
        {
            DrawLightning(&state.lightning[i]);
            state.lightningActive[i] = UpdateLightning(&state.lightning[i]);
        }
    }

    // detect and process crashes
    CrashNodeState * s1 = &state.nodes[0];
    CrashNodeState * s2 = &state.nodes[1];
    if (CrashOverlaps(s1,s2,4))
    { // will cross barrier this frame
      // reverse direction, start crash

        // start crash
        InitLightning(&state.lightning[0], s1->position.value, 10*s1->position.delta, NUM_PIXELS/2, vis->fps);
        InitLightning(&state.lightning[1], s2->position.value, 10*s2->position.delta, NUM_PIXELS/2, vis->fps);
        state.lightningActive[0] = true;
        state.lightningActive[1] = true;

        // reverse direction
        FixedPoint d2 = s2->position.delta;
        s2->position.delta = s1->position.delta;
        s1->position.delta = d2;

    }

    // save settings
    VisSaveObject(vis,&state,sizeof(state));
}


typedef struct
{
    Particle_t position;
    int32_t runCount;
    uint16_t runLengths[10];
} PassingsState;


// two colored items passing each other
void Passings(Visualization * vis)
{
#define MAX_STATE 2  // number of state entries
    PassingsState state[MAX_STATE];

    // load settings
    VisLoadObject(vis,state,sizeof(state));

    ColorBatch_t * cb = &vis->colorBatch;

    int32_t i,j;
    if (vis->frame == 0)
    { // initialize

        ColorBatchInitSimple(
            cb,      // the color batch to initialize
            MAX_STATE, // inclusive min number of distinct hues
            MAX_STATE, // inclusive max number of distinct hues
            7,       // inclusive min number of shades per hue
            7,       // inclusive max number of shades per hue
            FixedPoint(1),         // animation speed scaling, default to 1, larger is faster
            vis->fps // frames per second for updates, sets default animation rates
        );

        for (i = 0 ; i < MAX_STATE; ++i)
        {

            DirectionMode_t dir = (i&1)?DIRECTION_POSITIVE:DIRECTION_NEGATIVE;
            ParticleInit(&state[i].position,0,NUM_PIXELS,NUM_PIXELS*2,7,15,vis->fps,dir);
            state[i].runCount = GetRunsCount(
                    state[i].runLengths,  // run lengths, must be enough to hold possible answers
                    -1,    // min number of runs, or -1 for don't care
                    sizeof(state[i].runLengths)/sizeof(uint16_t),    // max number of runs, or -1 for don't care
                    5,       // min run length, -1 for don't care
                    25,      // max run length, -1 for don't care
                    RUN(3)|RUN(6)|RUN(9)|RUN(12),   // bit n=0,1,..,31 set if (n+1) desired to be a # of runs
                    true,   // allow even # of run counts
                    false,  // allow odd number of runs
                    false   // require exact divisors
            );
        }
    }

    // update
    Fill(0,0,0);
    ColorBatchUpdate(cb);

    for (j = 0 ; j < MAX_STATE; ++j)
    {
        PassingsState * s = state+j;

        int32_t start = FixedPointToInteger(s->position.value);

        // draw
        for (i = 0; i < NUM_PIXELS; ++i)
        {
            int offset;
            int runIndex = GetRunIndex(i,s->runLengths, s->runCount, &offset);
            if ((runIndex%3)==0 && offset < 7)
            {
                int32_t r,g,b;
                ColorBatchGetRGB(cb,j,7-offset,&r,&g,&b);
                int pos = PositiveMod(start+i,NUM_PIXELS);
                SetPixel(pos,r,g,b);
            }
        }

        ParticleUpdate(&s->position,0,NUM_PIXELS,ENDPOINT_WRAP);

    }

#undef MAX_STATE // clean up

    // save settings
    VisSaveObject(vis,state,sizeof(state));
}
 

typedef struct
{
    Particle_t angle;        // angle tells phase of drawing
    EndpointMode_t fillDirection; // how angle wraps, causing fills to bounce or all go in one direction
    FixedPoint scale; // causes some of ends 0 and 1 on angle to be chopped off
    int32_t hue;             // current hue to draw
    DirectionMode_t hueDirection;
    int32_t saturation;
    int32_t lightness;
    
    int32_t  runCount;
    uint16_t runLengths[10];
} VenetianBlindState;

void VenetianBlind(Visualization * vis)
{
    VenetianBlindState state;

    // load settings
    VisLoadObject(vis,&state,sizeof(state));

    int32_t i,j,r,g,b;
    if (vis->frame == 0)
    { // initialize

        state.runCount = 
            GetRunsCount(
                    state.runLengths,  // run lengths, must be enough to hold possible answers
                    2 ,   // min number of runs, or -1 for don't care
                    sizeof(state.runLengths)/sizeof(uint16_t),   // max number of runs, or -1 for don't care
                    -1,   // min run length, -1 for don't care
                    -1,   // max run length, -1 for don't care
                    RUN(3)|RUN(4)|RUN(5)|RUN(6)|RUN(7)|RUN(8)|RUN(9),    // bit n=0,1,..,31 set if (n+1) desired to be a # of runs
                    true, // allow even # of run counts
                    true, // allow odd number of runs
                    false // require exact divisors
            );

        state.fillDirection = rand8()>127?ENDPOINT_BOUNCE:ENDPOINT_WRAP;
        ParticleInit(&state.angle,0,0,3,3,5,vis->fps,DIRECTION_RANDOM);
        state.hue = randMod(HSLMAX+1);
        state.saturation = HSLMAX;
        state.lightness = HSLMAX/2;
        state.hueDirection = rand8()>127?DIRECTION_NEGATIVE:DIRECTION_POSITIVE;
        state.scale = FixedPoint(6)/4;

        Fill(0,0,0);
    }

    if (ParticleUpdate(&state.angle,0,1,state.fillDirection))
    {
        state.hue = NextHue(state.hue, 400, 800, state.hueDirection);
        int val = randMod(HSLMAX/2);
        state.saturation = HSLMAX-val/2;
        state.lightness = HSLMAX/2+val/2;
    }

    FixedPoint value = FixedPointMultiply(state.angle.value - FixedPoint(1)/2,state.scale)+FixedPoint(1)/2;
    value = Clamp(value,0,FixedPoint(1));

    FixedPoint fillStart, fillEnd; // amount to fill in 0-1 each
    if (state.angle.delta > 0)
    { // increasing to fill
        fillStart = 0;
        fillEnd = value;
    }
    else
    { // decreasing to fill
        fillStart = value;
        fillEnd   = FixedPoint(1);
    }

    HSLToRGB(state.hue,state.saturation,state.lightness,&r,&g,&b);

    FixedPoint runStart = 0;
    for (j = 0; j < state.runCount; ++j)
    {
        FixedPoint start = runStart + fillStart*state.runLengths[j];
        FixedPoint end   = runStart + fillEnd*state.runLengths[j];

        for (i = FixedPointToInteger(start); i < FixedPointToInteger(end); ++i)
            SetPixel(i,r,g,b);

        runStart += FixedPoint(state.runLengths[j]);
    }

    // save settings
    VisSaveObject(vis,&state,sizeof(state));
}


typedef struct
{
   Particle_t hue;        // color and change
   Particle_t position;   // movement angle and change
} LayerSliderState;

void LayerSlider(Visualization * vis)
{
#define MAX_STATE 2
    LayerSliderState state[MAX_STATE];

    // load settings
    VisLoadObject(vis,state,sizeof(state));
    uint8_t lastOverlap,onTop;
    UNPACK2(vis->simpleState1,lastOverlap,1,onTop,1);

    int32_t i;
    if (vis->frame == 0)
    { // initialize
        for (i = 0 ; i < MAX_STATE; ++i)
        {
            DirectionMode_t dir = i==0?DIRECTION_POSITIVE:DIRECTION_NEGATIVE;
            ParticleInit(&state[i].hue,0,HSLMAX,HSLMAX,40,80,vis->fps,DIRECTION_RANDOM);
            ParticleInit(&state[i].position,0,0,NUM_PIXELS,6,9,vis->fps,dir);
            
        }
        lastOverlap = 0;
        onTop = 0;
    }

    // draw
    Fill(0,0,0);
    bool overlapped = false;
    for (i = 0; i < MAX_STATE; ++i)
    {
        int32_t j,width,jStart;
        
        width = NUM_PIXELS/8;

        int32_t r,g,b,h,r1,g1,b1;
        h = FixedPointToInteger(state[i].hue.value);
        HSLToRGB(h,HSLMAX,HSLMAX/2,&r,&g,&b);

        jStart = FixedPointToInteger(state[i].position.value);
        for (j = jStart; j < jStart+width; ++j)
        {
            int32_t pos = PositiveMod(j,NUM_PIXELS);

            GetPixel(pos,&r1,&g1,&b1);
            if (r1+g1+b1 != 0)
                overlapped = true;
            if (r1+g1+b1 == 0 || onTop)
                SetPixel(pos,r,g,b);
            pos = PositiveMod(pos+NUM_PIXELS/2,NUM_PIXELS);
            GetPixel(pos,&r1,&g1,&b1);
            if (r1+g1+b1 != 0)
                overlapped = true;
            if (r1+g1+b1 == 0 || onTop)
                SetPixel(pos,r,g,b);
        }

        ParticleUpdate(&state[i].hue,0,HSLMAX,ENDPOINT_WRAP);
        ParticleUpdate(&state[i].position,0,NUM_PIXELS,ENDPOINT_WRAP);
    }

    // toggle overlap states
    if (lastOverlap && !overlapped)
        onTop ^= 1;
    lastOverlap = overlapped?1:0;


    // save settings
    VisSaveObject(vis,state,sizeof(state));
    PACK2(vis->simpleState1,lastOverlap,1,onTop,1);
#undef MAX_STATE
}


typedef struct
{
    uint16_t runLengths[10];
    int32_t  runCount;
    int32_t  hue;             // last hue used for fill
    DirectionMode_t hueDirection; // hue movement direction
    int32_t  hueWidth;        // width for hue random choices
    int32_t  framesStable;    // number of frames between changing
    int32_t  framesPerChange; // number of frames between changes
    int32_t  frameState;      // counts frames in a cycle
} NColorState;

void NColor(Visualization * vis)
{

    NColorState state;
    int32_t i,r,g,b;
    
    VisLoadObject(vis,&state,sizeof(state));

    if (vis->frame == 0)
    { // initialize
        state.runCount = GetRunsCount(
                state.runLengths,  // run lengths, must be enough to hold possible answers
                -1 ,   // min number of runs, or -1 for don't care
                sizeof(state.runLengths)/sizeof(uint16_t),   // max number of runs, or -1 for don't care
                5,   // min run length, -1 for don't care
                NUM_PIXELS/2,   // max run length, -1 for don't care
                RUN(3)|RUN(4)|RUN(5)|RUN(6)|RUN(7)|RUN(8),    // bit n=0,1,..,31 set if (n+1) desired to be a # of runs
                true, // allow even # of run counts
                true, // allow odd number of runs
                false  // require exact divisors
        );

        state.hueDirection = rand8()>127?DIRECTION_POSITIVE:DIRECTION_NEGATIVE;
        state.frameState = 0;
        state.framesPerChange = vis->fps/(state.runCount); // do all in 1 second
        state.framesStable    = vis->fps*randMod2(3,6); // 3-6 seconds wait
        if (state.framesPerChange <= 0)
            state.framesPerChange = 1; // at least one

        state.hue = randMod(HSLMAX);
        state.hueWidth = randMod2(HSLMAX/6,2*HSLMAX/6);

        Fill(0,0,0);
    }


    if (state.frameState == 0)
    { // new color base
        state.hue = NextHue(state.hue, 400, 800, state.hueDirection);
    }

    if (state.frameState < state.runCount * state.framesPerChange &&
        (state.frameState%state.framesPerChange) == 0)
    { // flip a color
        int index = state.frameState/state.framesPerChange;
        
        int32_t start, end;
        GetRunPosition(index, state.runLengths, state.runCount, &start, &end);

        int32_t h     = PositiveMod(state.hue + LowDiscrepancySequence(0,0,state.hueWidth,index),HSLMAX+1);
        int32_t sat   = LowDiscrepancySequence(4*HSLMAX/5,4*HSLMAX/5,HSLMAX,index);
        int32_t light = LowDiscrepancySequence(HSLMAX/2,5*HSLMAX/11,7*HSLMAX/10,index);

        HSLToRGB(h,sat,light,&r,&g,&b);
        for (i = start; i < end; ++i)
            SetPixel(i,r,g,b);
    }
    state.frameState = PositiveMod(state.frameState+1,state.framesPerChange*state.runCount + state.framesStable);

    VisSaveObject(vis,&state,sizeof(state));
}

/* sparkle:
 *
 * 1. Has global hue
 * 2. Fades from dim/gray, through hue to global white,
 * 3. then sparkles back down to dark, new hue
 * 4. want individual sparkles
 * 5. don't change state till all done in one state
 *
 * Have about 5 bytes per pixel right now....
 *  */

typedef struct
{
    int32_t stateLengths[10];
    int32_t frameInCycle;    // frame in current up/down cycle
    int32_t hue;             // current hue
    bool restart;
} SparkleState;

// given a list of state lengths, and an index into the total, return the
// state index, or -1 if out of bounds.
// Also compute ratio in [0,1) into the given state
int GetStateIndex(int32_t index, const int32_t * stateLengths, int stateCount, FixedPoint * ratio)
{
    int i = 0;
    *ratio = 0;
    while (i < stateCount && index >= stateLengths[i])
    {
        index -= stateLengths[i];
        ++i;
    }
    if (i >= stateCount)
        return -1;
    if (stateLengths[i] != 0)
        *ratio = FixedPoint(index)/stateLengths[i];
    return i;
}

void Sparkle(Visualization * vis)
{

    SparkleState state;

    // load settings
    VisLoadObject(vis,&state,sizeof(state));

    int32_t i;
    if (vis->frame == 0 || state.restart)
    { // initialize

        i = 0;
        // fade up count
        state.stateLengths[i++] = randMod2(2*vis->fps,5*vis->fps);
        // hold sparkle count
        state.stateLengths[i++] = vis->fps;
        // sparkle down count
        state.stateLengths[i++] = randMod2(2*vis->fps/3,8*vis->fps/4);
        // wait at bottom count
        state.stateLengths[i++] = 0; // vis->fps/4;
        state.frameInCycle = 0;
        state.hue = randMod(HSLMAX+1);
        state.restart = false;
    }

    int32_t h,s,l,r,g,b;

    FixedPoint ratio; // in [0,1)
    int32_t index = GetStateIndex(state.frameInCycle, state.stateLengths, 4, &ratio);

    switch (index)
    {
        case 0 :
            // fade up
            h = state.hue;
            s = FixedPointToInteger(ratio*HSLMAX);
            l = s;
            HSLToRGB(h,s,l,&r,&g,&b);
            Fill(r,g,b);
            break;
        case 1 :
            // hold flicker
            ratio = FixedPoint(0); // hold here
            // fall through to next
        case 2 :
            // flicker down
            h = state.hue;
            const int32_t lMin = HSLMAX/4;
            const int32_t lMax = HSLMAX;
            l = FixedPointToInteger((lMax-lMin)*(FixedPoint(1)-ratio))+lMin;
            s = 0;
            for (i = 0; i < NUM_PIXELS; ++i)
            {
                int32_t l2,s2;
                l2 = l;
                s2=s;
                if (randMod(100)<10)
                {
                    l2 = randMod2(l/8,l*6/8);
                }
                HSLToRGB(h,s2,l2,&r,&g,&b);
                SetPixel(i,r,g,b);
            }
            break;
        case 3 :
            // wait at bottom
            Fill(0,0,0);
            break;
        case -1 :
            state.frameInCycle = -1;
            state.restart = true;
            break;
    }


    state.frameInCycle++;
    
    // save settings
    VisSaveObject(vis,&state,sizeof(state));
}


typedef struct 
{
    Particle_t position;
    int32_t hueDelta;
} RacerState;

void Racers(Visualization * vis)
{
    // each entry is a d,r,g,b bytes, where d is signed delta, rest unsigned color
#define MAX_STATE (NUM_PIXELS/10) // (VIS_STATE_SIZE/sizeof(RacerState))
    RacerState state[MAX_STATE];

    // load settings
    VisLoadObject(vis,state,sizeof(state));
    ColorBatch_t * cb = &(vis->colorBatch);

    int32_t i;
    if (vis->frame == 0)
    { // initialize
        ColorBatchInitSimple(
            cb,      // the color batch to initialize
            1,       // inclusive min number of distinct hues
            5,       // inclusive max number of distinct hues
            1,       // inclusive min number of shades per hue
            1,       // inclusive max number of shades per hue
            randMod2(FixedPoint(1)/5,FixedPoint(1)),         // animation speed scaling, default to 1, larger is faster
            vis->fps // frames per second for updates, sets default animation rates
        );
        DirectionMode_t direction = rand8()>127?DIRECTION_POSITIVE:DIRECTION_NEGATIVE;
        for (i = 0; i < MAX_STATE; ++i)
        {
            ParticleInit(&state[i].position,0,NUM_PIXELS,NUM_PIXELS,2,4,vis->fps,direction);
            state[i].hueDelta = randMod2(-HSLMAX/24,HSLMAX/24+1);
        }
    }

    Fade(0,0,0,15);
    ColorBatchUpdate(cb);
    for (i = 0; i < MAX_STATE; ++i)
    {
        ParticleUpdate(&state[i].position,0,NUM_PIXELS,ENDPOINT_WRAP);
        int32_t p = FixedPointToInteger(state[i].position.value);
        int32_t r,g,b,h,s,l;
        ColorBatchGetHSL(cb,i%cb->swatchCount,0,&h,&s,&l);
        HSLToRGB(PositiveMod(h+state[i].hueDelta,HSLMAX+1),s,l,&r,&g,&b);
        OrPixel(p,r,g,b);
    }

#undef MAX_STATE
    
    // save settings
    VisSaveObject(vis,state,sizeof(state));

}

typedef struct
{
    int32_t runCount;
    uint16_t runLengths[10];
    Particle_t position;
} RunnerState;

void Runner(Visualization * vis)
{
    RunnerState state;

    // load settings
    VisLoadObject(vis,&state,sizeof(state));

    ColorBatch_t * cb = &(vis->colorBatch);

    int32_t i,j;
    if (vis->frame == 0)
    { // initialize
        ColorBatchInitSimple(
            cb,      // the color batch to initialize
            1,       // inclusive min number of distinct hues
            5,       // inclusive max number of distinct hues
            1,       // inclusive min number of shades per hue
            7,       // inclusive max number of shades per hue
            randMod2(FixedPoint(1)/2,FixedPoint(3)),         // animation speed scaling, default to 1, larger is faster
            vis->fps // frames per second for updates, sets default animation rates
        );
        ParticleInit(&state.position,0,NUM_PIXELS,NUM_PIXELS,4,5,vis->fps,DIRECTION_RANDOM);
        state.runCount = GetRunsCount(
                state.runLengths,  // run lengths, must be enough to hold possible answers
                 2,    // min number of runs, or -1 for don't care
                sizeof(state.runLengths)/sizeof(uint16_t),    // max number of runs, or -1 for don't care
                 8,      // min run length, -1 for don't care
                -1,      // max run length, -1 for don't care
                RUN(2)|RUN(4)|RUN(6)|RUN(8)|RUN(10)|RUN(12),     // bit n=0,1,..,31 set if (n+1) desired to be a # of runs
                true,    // allow even # of run counts
                false,   // allow odd number of runs
                false    // require exact divisors
                );
    }

    ColorBatchUpdate(cb);
    ParticleUpdate(&state.position,0,NUM_PIXELS,ENDPOINT_WRAP);

    // for every other run, draw it shifted
    for (i = 0; i < state.runCount; i+=2)
    {
        int32_t start,end;
        GetRunPosition(i, state.runLengths, state.runCount, &start, &end);

        int32_t length = end-start;

        int32_t hue;
        ColorBatchGetHSL(cb,(i/2)%cb->swatchCount, 0, &hue,NULL,NULL);
        
        // slow falloff computations
        FixedPoint lFp = FixedPoint(HSLMAX/2);
        FixedPoint ddl = FixedPoint(4*(HSLMAX+1))/(length*length);
        FixedPoint dl  = 0; // todo make corrrect? FixedPointMultiply(FixedPoint(excess)/shiftRate,ddl);

        Fade(0,0,0,10); 

        // draw it
        int32_t r,g,b;
        for (j = 0; j < length; ++j)
        {
            HSLToRGB(hue,FixedPointToInteger(lFp*2),FixedPointToInteger(lFp),&r,&g,&b);
            lFp -= dl;
            dl += ddl;
            if (lFp < 0) lFp = 0;

            int32_t pos = PositiveMod(j+start+FixedPointToInteger(state.position.value),NUM_PIXELS);
            SetPixel(pos,r,g,b);
        }
    }

    // save settings
    VisSaveObject(vis,&state,sizeof(state));
}

typedef struct {
    // a wave is defined by an amplitude (how far it swings),
    // an angle rate (how fast it swings, per frame),
    // a rate (how much it moves per frame, directed),
    // and a color
    Particle_t amplitude;
    Particle_t center;
    Particle_t hue;
    Particle_t angle;
    int32_t hueDelta; // shift hue by this on draw
} WaveStruct;



void Waves(Visualization * vis)
{
#define WAVE_COUNT 5
    WaveStruct state[WAVE_COUNT];

    VisLoadObject(vis,state,sizeof(state));
    ColorBatch_t * cb = &(vis->colorBatch);

    int32_t i,waveCount,fadeRate;

    UNPACK2(vis->simpleState1,waveCount,5,fadeRate,5);

    if (vis->frame == 0)
    { // init
        ColorBatchInitSimple(
            cb,      // the color batch to initialize
            1,       // inclusive min number of distinct hues
            5,       // inclusive max number of distinct hues
            1,       // inclusive min number of shades per hue
            1,       // inclusive max number of shades per hue
            randMod2(FixedPoint(1)/5,FixedPoint(1)),         // animation speed scaling, default to 1, larger is faster
            vis->fps // frames per second for updates, sets default animation rates
        );

        waveCount = randMod2(3,WAVE_COUNT);

        DirectionMode_t direction = rand8()>127?DIRECTION_POSITIVE:DIRECTION_NEGATIVE;
        for (i = 0; i < waveCount; ++i)
        {
            ParticleInit(&state[i].amplitude,NUM_PIXELS/5,NUM_PIXELS/3,NUM_PIXELS,13,27,vis->fps,DIRECTION_RANDOM);
            ParticleInit(&state[i].hue,0,HSLMAX,HSLMAX,12,20,vis->fps,DIRECTION_RANDOM);
            ParticleInit(&state[i].angle,0,1,1,2,3,vis->fps,DIRECTION_RANDOM);
            ParticleInit(&state[i].center,0,NUM_PIXELS,NUM_PIXELS,15,25,vis->fps,direction);
            state[i].hueDelta = randMod2(-NUM_PIXELS/24, 1+NUM_PIXELS/24);
            state[i].angle.delta = state[0].angle.delta; // nice if in phase
        }

        // equally space centers, make same speed
        FixedPoint speed = state[0].center.delta;
        for (i =0; i < waveCount; ++i)
        {
            state[i].center.value = FixedPoint(i*NUM_PIXELS)/waveCount;
            state[i].center.delta = speed;
            state[i].angle.value = FixedPoint(i)/(waveCount);
            state[i].amplitude.value = 3*FixedPoint(NUM_PIXELS)/(4*waveCount);
            state[i].amplitude.delta  = 0;
        }

        fadeRate = randMod2(5,6); // fade rate
    }

    Fade(0,0,0,fadeRate);

    ColorBatchUpdate(cb);

    for (i = 0; i < waveCount; ++i)
    {
        // compute and draw it
        ParticleUpdate(&state[i].hue, 0,HSLMAX,ENDPOINT_WRAP);
        ParticleUpdate(&state[i].angle, 0,1,ENDPOINT_WRAP);
        ParticleUpdate(&state[i].center, 0,NUM_PIXELS,ENDPOINT_WRAP);
        //ParticleUpdate(&state[i].amplitude, NUM_PIXELS/5,NUM_PIXELS/3,ENDPOINT_BOUNCE);

        FixedPoint t = Sin(state[i].angle.value)- FixedPoint(1)/2;
        t = FixedPointMultiply(state[i].amplitude.value,t);
        t += state[i].center.value;
        int32_t j = PositiveMod(FixedPointToInteger(t),NUM_PIXELS);

        int32_t r,g,b;
        int32_t h = FixedPointToInteger(state[i].hue.value);
        //ColorBatchGetHSL(cb,i%(cb->swatchCount),0,&h,NULL,NULL);
        //h=PositiveMod(h+state[i].hueDelta,HSLMAX+1);
        HSLToRGB(h,HSLMAX,HSLMAX/2,&r,&g,&b);

        SetPixel(j,r,g,b);
    }

    PACK2(vis->simpleState1,waveCount,5,fadeRate,5);

    VisSaveObject(vis,state,sizeof(state));
    
#undef WAVE_COUNT
}


typedef struct
{
    Particle_t hue;
    Particle_t position; // center
    FixedPoint minLf;    // min luminance
    FixedPoint maxLf;    // max luminance
    int32_t   periods;   // number of periods
} WhiteColorGradientState;

void WhiteColorGradient(Visualization * vis)
{
    WhiteColorGradientState state;
    int32_t frame = vis->frame;
    
    // load state
    VisLoadObject(vis,&state,sizeof(state));

    if (frame == 0)
    { // init
        ParticleInit(&state.hue, 0, HSLMAX, HSLMAX, 12, 23, vis->fps, DIRECTION_RANDOM);
        ParticleInit(&state.position, 0, NUM_PIXELS-1, NUM_PIXELS, 5, 9, vis->fps, DIRECTION_RANDOM);
        state.minLf = randMod(FixedPoint((HSLMAX+1))/16);
        state.maxLf = FixedPoint(HSLMAX);
        state.periods = randMod2(1,2);
    }

    ParticleUpdate(&state.hue, 0, HSLMAX+1, ENDPOINT_WRAP);
    ParticleUpdate(&state.position, 0, NUM_PIXELS, ENDPOINT_WRAP);
   
    int32_t r,g,b;
    int32_t i;
    int32_t hue = FixedPointToInteger(state.hue.value);
    int32_t shift = FixedPointToInteger(state.position.value);
    
    for (i = 0; i < NUM_PIXELS; ++i)
    {
        FixedPoint val = Sin(FixedPoint(state.periods*i)/NUM_PIXELS)*HSLMAX;
        val = FixedPointDivide(val-state.minLf,state.maxLf-state.minLf)*HSLMAX+state.minLf;

        int32_t lightness = FixedPointToInteger(val);
        int32_t pos = PositiveMod(i + shift,NUM_PIXELS);

        HSLToRGB(hue,HSLMAX,lightness,&r,&g,&b);
        SetPixel(pos,r,g,b);
    }

    // save state
    VisSaveObject(vis,&state,sizeof(state));
}

typedef struct 
{
    int32_t runCount;
    uint16_t runLengths[10];
    Particle_t angle1; // drives luminance 1
    Particle_t angle2; // drives luminance 2
    Particle_t hue1;
    Particle_t hue2;
    bool syncColors;
} TwoColorState;

void TwoColor(Visualization * vis)
{
    TwoColorState state;
    int32_t frame = vis->frame;

    // load state
    VisLoadObject(vis,&state,sizeof(state));

    if (frame == 0)
    { // init

        state.runCount = GetRunsCount(
                state.runLengths,  // run lengths, must be enough to hold possible answers
                2,     // min number of runs, or -1 for don't care
                sizeof(state.runLengths)/sizeof(uint16_t),   // max number of runs, or -1 for don't care
                4,     // min run length, -1 for don't care
                -1,    // max run length, -1 for don't care
                RUN(2)|RUN(4)|RUN(6)|RUN(8)|RUN(10)|RUN(12),    // bit n=0,1,..,31 set if (n+1) desired to be a # of runs
                true,  // allow even # of run counts
                false, // allow odd number of runs
                false  // require exact divisors
        );

        ParticleInit(&(state.angle1),0,1,1,2,5,vis->fps,DIRECTION_RANDOM);
        ParticleInit(&(state.angle2),0,1,1,2,5,vis->fps,DIRECTION_RANDOM);
        ParticleInit(&(state.hue1),0,HSLMAX,HSLMAX,3,8,vis->fps,DIRECTION_RANDOM);
        ParticleInit(&(state.hue2),0,HSLMAX,HSLMAX,2,7,vis->fps,DIRECTION_RANDOM);

        state.syncColors = (rand32()%5)==0;
    }

    if (ParticleUpdate(&state.angle1,0,1,ENDPOINT_WRAP))
    {
        if (state.syncColors)
            state.hue1.value = randMod(FixedPoint(HSLMAX));
        else
            state.hue1.value += state.hue2.value;
    }
    if (ParticleUpdate(&state.angle2,0,1,ENDPOINT_WRAP))
    {
        if (state.syncColors)
            state.hue2.value = state.hue1.value;
        else
            state.hue2.value += state.hue1.value;
    }

    int32_t l1 = FixedPointToInteger(HSLMAX*Cos(state.angle1.value)/2);
    int32_t l2 = FixedPointToInteger(HSLMAX*Cos(state.angle2.value)/2);

    int32_t i,j;
    // color each run
    for (i = 0; i < state.runCount; ++i)
    {
        int32_t start, end;
        GetRunPosition(i, state.runLengths, state.runCount, &start, &end);

        int32_t r,g,b;
        if (i&1)
            HSLToRGB(FixedPointToInteger(state.hue1.value),HSLMAX,l1,&r,&g,&b);
        else
            HSLToRGB(FixedPointToInteger(state.hue2.value),HSLMAX,l2,&r,&g,&b);
        for (j = start; j < end; ++j)
            SetPixel(j,r,g,b);
    }

    // save state
    VisSaveObject(vis,&state,sizeof(state));
}



typedef struct
{
    Particle_t hue;
    SatLight_t satLight;
    bool useFade;
} CircleHueState;

void CircleHue(Visualization * vis, bool slow)
{
    CircleHueState state;

    // load settings
    VisLoadObject(vis,&state,sizeof(state));

    if (vis->frame == 0)
    { // initialize

        int scale = slow?1:3;


        ParticleInit(&state.hue,0,HSLMAX,HSLMAX,9/scale,15/scale,vis->fps,DIRECTION_RANDOM);
        state.useFade = rand8()<64; // 1 in 4 or so

        SatLightInit(&state.satLight,FixedPoint(scale),vis->fps);
    }

    // update and draw
    ParticleUpdate(&state.hue,0,HSLMAX+1,ENDPOINT_WRAP);
    SatLightUpdate(&state.satLight);

    int32_t i;
    for (i = 0; i < NUM_PIXELS; ++i)
    {
        int32_t r,g,b;
        int32_t hue = FixedPointToInteger(
                state.hue.value+FixedPoint(i*HSLMAX)/NUM_PIXELS
                );
        int32_t sat,light;
        SatLightGetSL(&state.satLight,i,&sat,&light);

        HSLToRGB(hue,sat,light,&r,&g,&b);
        SetPixel(i,r,g,b);
    }
    
    // save settings
    VisSaveObject(vis,&state,sizeof(state));
}

void CircleHueFast(Visualization * vis)
{
    CircleHue(vis,false);
}
void CircleHueSlow(Visualization * vis)
{
    CircleHue(vis,true);
}


void SolidHue(Visualization * vis)
{
    
    int32_t r1,g1,b1,h1,s1,l1;

    h1 = vis->frame;
    s1 = HSLMAX;
    l1 = HSLMAX/2;
    
    HSLToRGB(h1,s1,l1,&r1,&g1,&b1);
    Fill(r1,g1,b1);
}


typedef struct
{
    Particle_t position;
    Particle_t colors[3];
} BouncerState;

void Bouncer(Visualization * vis)
{
#define MAX_STATE ((VIS_STATE_SIZE)/(sizeof(BouncerState)))  // number of state entries
    BouncerState state[MAX_STATE];

    //Print("Bouncersize: %d, max_state %d."ENDLINE,sizeof(BouncerState),MAX_STATE);

    // load settings
    VisLoadObject(vis,state,sizeof(state));

    int blobCount,temp;
    UNPACK2(vis->simpleState1,blobCount,5,temp,5);

    int32_t i,j;
    if (vis->frame == 0)
    { // initialize
        blobCount = randMod2(4,min(7,MAX_STATE));
        for (i = 0; i < blobCount; ++i)
        {
            BouncerState * s = state+i;

            ParticleInit(&(s->position), // the particle
                    0,                   // min random position
                    NUM_PIXELS,          // max random position
                    60,                  // for pixels per second
                    1,                   // min time to move in seconds
                    2,                   // max time to move in seconds
                    vis->fps,            // frames per second update will be called
                    0                    // -1 for negative, +1 for positive, 0 for random
                );

            int32_t j;
            for (j = 0; j < 3; ++j)
            {
                Particle_t * color = &(s->colors[j]);
                ParticleInit(color, // the particle
                        0,                   // min random position
                        255,                 // max random position
                        60,                  // desired change in the time interval
                        1,                   // min time to change in seconds
                        2,                   // max time to change in seconds
                        vis->fps,            // frames per second update will be called
                        0                    // -1 for negative, +1 for positive, 0 for random
                    );
            }
        }
    }

    // update and draw
    Fade(0,0,0,200);
    for (i = 0; i < blobCount; ++i)
    {
        BouncerState * s = state+i;

        SetPixel(
                FixedPointToInteger(s->position.value),
                FixedPointToInteger(s->colors[0].value),
                FixedPointToInteger(s->colors[1].value),
                FixedPointToInteger(s->colors[2].value)
                );

        ParticleUpdate(&(s->position), // particle to update
            0,                         // min allowed value
            NUM_PIXELS,                // max allowed value
            ENDPOINT_BOUNCE            // what to do on end: PARTICLE_WRAP, , or PARTICLE_CLAMP
            );

        for (j = 0; j < 3; ++j)
        {
            Particle_t * color = &(s->colors[j]);
            ParticleUpdate(color,          // particle to update
                0,                         // min allowed value
                255,                       // max allowed value
                ENDPOINT_BOUNCE            // what to do on end: PARTICLE_WRAP, , or PARTICLE_CLAMP
                );
        }
    }

#undef MAX_STATE // clean up

    // save settings
    VisSaveObject(vis,state,sizeof(state));
    PACK2(vis->simpleState1,blobCount,5,temp,5);
}


/* todo - implement plasma in HSL space, make periodic on length
 * take n points, move them up and down by sin/cos in some form,
 * use as control points for bezier curve, makes periodic

 * then hue in 0-1, maps position in 0-1 to 0-1, in between bezier moves points around.
 * sat and lum in some range, endpoints fixed, middle only moves so much....
     */
// standard plasma
typedef struct
{
    Hump_t hueHump;
} PlasmaStruct;

void Plasma(Visualization * vis)
{
#define PLASMA_COUNT 4
    PlasmaStruct state[PLASMA_COUNT];

    VisLoadObject(vis,state,sizeof(state));

    int32_t i, baseHue;

    UNPACK2(vis->simpleState1,baseHue,10,i,1);

    if (vis->frame == 0)
    { // init
        for (i = 0; i < PLASMA_COUNT; ++i)
            {
            // each hump in [0,1], positioned over pixels
            HumpInit(&state[i].hueHump,
                0,     // min random position
                NUM_PIXELS,     // max random position
                NUM_PIXELS,     // desired change in time interval
                DIRECTION_RANDOM, // DIRECTION_NEGATIVE, DIRECTION_RANDOM, or DIRECTION_POSITIVE

                15,     // min random width
                30,     // max random width
                2,     // desired width change in time interval
                DIRECTION_RANDOM, // DIRECTION_NEGATIVE, DIRECTION_RANDOM, or DIRECTION_POSITIVE

                0,     // min random height
                1,     // max random height
                1,     // desired height change in time interval
                DIRECTION_RANDOM, // DIRECTION_NEGATIVE, DIRECTION_RANDOM, or DIRECTION_POSITIVE

                2,       // min time to change in seconds
                5,       // max time to change in seconds
                vis->fps                 // frames per second update will be called
                );
        }
        baseHue = randMod(HSLMAX);
    }

    int j,r,g,b;
    for (j = 0; j < PLASMA_COUNT; ++j)
    {
        HumpUpdate(&state[j].hueHump,
            0,      // min allowed position value
            NUM_PIXELS,      // max allowed position value
            ENDPOINT_BOUNCE,// what to do on end: PARTICLE_WRAP, PARTICLE_BOUNCE, or PARTICLE_CLAMP
            15,      // min allowed width value
            30,      // max allowed width value
            ENDPOINT_BOUNCE,// what to do on end: PARTICLE_WRAP, PARTICLE_BOUNCE, or PARTICLE_CLAMP
            0,      // min allowed height value
            1,      // max allowed height value
            ENDPOINT_BOUNCE // what to do on end: PARTICLE_WRAP, PARTICLE_BOUNCE, or PARTICLE_CLAMP
            );
    }
    for (i = 0; i < NUM_PIXELS; ++i)
    {
        FixedPoint sum = 0;
        for (j = 0; j < PLASMA_COUNT; ++j)
        {
            sum += HumpEvaluate(
                &state[j].hueHump,   // the hump to evaluate
                FixedPoint(i),  // the parameter value
                0, // range min value
                NUM_PIXELS, // range max value
                ENDPOINT_WRAP // what to do on end: ENDPOINT_WRAP, ENDPOINT_BOUNCE, or ENDPOINT_CLAMP, ENDPOINT_UNBOUNDED
                );
        }
        int32_t hue = PositiveMod(baseHue + FixedPointToInteger(sum*HSLMAX),HSLMAX+1);
        HSLToRGB(hue,HSLMAX,HSLMAX/2,&r,&g,&b);
        SetPixel(i,r,g,b);
    }

    VisSaveObject(vis,state,sizeof(state));
    PACK2(vis->simpleState1,baseHue,10,i,1);

#undef PLASMA_COUNT
}

#define BLOCKS_MAX_RUNS 10
typedef struct
{
    Particle_t position;

    // 5 runs of length 10, or 10 runs of length 5
    uint16_t runLengths[BLOCKS_MAX_RUNS];
    int32_t runCount;

    uint8_t colors[BLOCKS_MAX_RUNS*3];
} BlocksState;

void SwapBlocksColor(int i, int j, void * blockState)
{
    BlocksState * bs = blockState;
    uint8_t * c1 = &(bs->colors[i*3]);
    uint8_t * c2 = &(bs->colors[j*3]);
    uint8_t t;
    t=*c1;
    *c1++ = *c2; 
    *c2++ = t;
    t=*c1;
    *c1++ = *c2;
    *c2++ = t;
    t=*c1;
    *c1++ = *c2;
    *c2++ = t;
}

void Blocks(Visualization * vis)
{
    BlocksState state;

    // load settings
    VisLoadObject(vis,&state,sizeof(state));

    int32_t i,j,r,g,b;
    if (vis->frame == 0)
    { // initialize


        // run count and lengths
        state.runCount = GetRunsCount(
                state.runLengths, // run lengths, must be enough to hold possible answers
                3,    // min number of runs, or -1 for don't care
                sizeof(state.runLengths)/sizeof(uint16_t),   // max number of runs, or -1 for don't care
                 4,    // min run length, -1 for don't care
                -1,    // max run length, -1 for don't care
                RUN(3)|RUN(4)|RUN(5)|RUN(6)|RUN(7)|RUN(8),   // bit n=0,1,..,31 set if (n+1) desired to be a # of runs
                true, // allow even # of run counts
                true, // allow odd number of runs
                false       // require exact divisors
                );


        ParticleInit(&state.position,0,NUM_PIXELS,NUM_PIXELS,3,4,vis->fps,DIRECTION_RANDOM);

        // color method: two hue cycles of full sat and light sat
        // if more than 5 colors, add white. If more than 8 colors, add gray:
        i = 0; // color index
        if (state.runCount >= 5)
        {
            state.colors[0] = state.colors[1] = state.colors[2] = 255;
            i+=3;
        }
        if (state.runCount >= 8)
        {
            state.colors[3] = state.colors[4] = state.colors[5] = 128;
            i+=3;
        }
        int colorsLeft = state.runCount - i/3;
        int fullHue = (colorsLeft+1)/2; // this many full hue
        int brightHue = colorsLeft-fullHue; // this many bright hue
        int j;
        int32_t hueStart = randMod(HSLMAX); // start here
        for (j = 0; j < fullHue; ++j)
        {
            int32_t hue = PositiveMod(hueStart + j*HSLMAX/fullHue, HSLMAX+1);
            HSLToRGB(hue,HSLMAX,HSLMAX/2,&r,&g,&b);
            state.colors[i++] = r;
            state.colors[i++] = g;
            state.colors[i++] = b;
        }
        hueStart = randMod(HSLMAX); // start here
        for (j = 0; j < brightHue; ++j)
        {
            int32_t hue = PositiveMod(hueStart + j*HSLMAX/brightHue, HSLMAX+1);
            HSLToRGB(hue,HSLMAX,3*HSLMAX/4,&r,&g,&b);
            state.colors[i++] = r;
            state.colors[i++] = g;
            state.colors[i++] = b;
        }

        // shuffle colors
        Shuffle(state.runCount,&state,SwapBlocksColor);
    }

    // update and draw
    ParticleUpdate(&state.position,0,NUM_PIXELS,ENDPOINT_WRAP);

    int shift = FixedPointToInteger(state.position.value);

    // draw each run, shifted
    for (i = 0; i < state.runCount; i ++)
    {
        int32_t r,g,b,k,c;
        c = i*3;
        r = state.colors[c++];
        g = state.colors[c++];
        b = state.colors[c  ];

        int32_t start, end;
        GetRunPosition(i, state.runLengths, state.runCount, &start, &end);

        for (j = start; j < end; ++j)
        {
            int pos = PositiveMod(j+shift,NUM_PIXELS);
            SetPixel(pos,r,g,b);
        }
    }

    // save settings
    VisSaveObject(vis,&state,sizeof(state));
}
#undef BLOCKS_MAX_RUNS // clean up

typedef struct
{
    int32_t fadeRate;
    int32_t nextSplatFrame;
    int32_t splatCount, startCount;
} SplatState;


void SplatDraw(ColorBatch_t * cb, int tintCount, int splatCount, int startCount)
{
    int32_t h,s,l;
    int32_t index = randMod(cb->swatchCount);

    int center = randUniform(NUM_PIXELS);

    center = LowDiscrepancySequence(startCount,0,NUM_PIXELS-1,splatCount);

    int width = randMod2(4,10);
    int start = center-width;
    int i;
    for (i = 0; i < 2*width; ++i)
    {

        // want tint index to go 0->tintCount-1->0
        int dist = width - abs(i-width); // 0->w->0
        int tintIndex = dist*(tintCount-1)/width;

        ColorBatchGetHSL(cb,index,tintIndex,&h,&s,&l);

//        s = HSLMAX;
//        l = HSLMAX/2;

  //      l = dist*HSLMAX/(2*width);

        int32_t r,g,b;
        HSLToRGB(h,s,l,&r,&g,&b);
        int pos = PositiveMod(i+start,NUM_PIXELS);
        SetPixel(pos,r,g,b);
    }

}


void Splat(Visualization * vis)
{
#define TINT_COUNT 9
    SplatState state;

    // load settings
    VisLoadObject(vis,&state,sizeof(state));

    ColorBatch_t * cb = &(vis->colorBatch);

    int32_t i,j;
    if (vis->frame == 0)
    { // initialize
        ColorBatchInitSimple(
            cb,      // the color batch to initialize
            1,       // inclusive min number of distinct hues
            2,       // inclusive max number of distinct hues
            TINT_COUNT,      // inclusive min number of shades per hue
            TINT_COUNT,      // inclusive max number of shades per hue
            randMod2(FixedPoint(1)/2,FixedPoint(3)),         // animation speed scaling, default to 1, larger is faster
            vis->fps // frames per second for updates, sets default animation rates
        );
        state.nextSplatFrame = 0;
        state.fadeRate = randMod(5);
        state.splatCount = 0;
        state.startCount = randMod(NUM_PIXELS);
    }

    // add one randomly if it is time
    if (state.nextSplatFrame == vis->frame)
    {
        SplatDraw(cb,TINT_COUNT, state.splatCount++, state.startCount);
        state.nextSplatFrame += randMod2(vis->fps/20,4*vis->fps/10); // sec till next splat
    }

    Fade(0,0,0,state.fadeRate);//vis->simpleState2); // 63/64 of old value - todo - make fps sensitive version?

    // update and draw
    ColorBatchUpdate(cb);

#undef TINT_COUNT // clean up

    // save settings
    VisSaveObject(vis,&state,sizeof(state));
}


void SolidFill(Visualization * vis)
{
    int angle = FixedPoint(vis->frame)>>14;
    int r,g,b;
    r=Sin(angle<<4);
    b=Sin((2*angle+81)<<4);
    g=Sin((3*angle+182)<<4);
    r=FixColor01(r);
    g=FixColor01(g);
    b=FixColor01(b);
    Fill(r,g,b);
    angle=(angle+1)&255;
}
 

typedef struct
{
    int32_t red,green,blue; // color masks
    Particle_t position;
} Orb;

void Bouncy(Visualization * vis)
{
#define NUM_ORBS 7
    Orb orbs [NUM_ORBS];

    int32_t i;

    // load state
    VisLoadObject(vis,orbs,sizeof(orbs));

    // initialize
    if (vis->frame == 0)
    {
        for (i = 0; i < 7; ++i)
        {
            orbs[i].red = (i+1)&1?255:0;
            orbs[i].green = (i+1)&2?255:0;
            orbs[i].blue = (i+1)&4?255:0;
            ParticleInit(&orbs[i].position,0,NUM_PIXELS,2*NUM_PIXELS,3,7,vis->fps,DIRECTION_RANDOM);
        }
    }

    // draw frame
    Fill(0,0,0);

    int32_t j;
    for (j = 0; j < NUM_ORBS; ++j)
    {
        Orb * orb = &orbs[j];
        int32_t i = FixedPointToInteger(orb->position.value);
        static const int masks[] = {32,64,255,64,32};
        int32_t j;
        for (j = -2; j <= 2; ++j)
        {
            int32_t k;
            k = PositiveMod(i+j,NUM_PIXELS);
            int mask = masks[j+2];
            OrPixel(k,orb->red&mask,orb->green&mask,orb->blue&mask);
        }

        ParticleUpdate(&orb->position,0,NUM_PIXELS,ENDPOINT_BOUNCE);
    }

    // save state
    VisSaveObject(vis,orbs,sizeof(orbs));
#undef NUM_ORBS
}

typedef struct
{
    // fill all at once, or fill with random timing
    bool sync;           
    // how many get filled per frame if random timing, else fill all when wraps
    Particle_t fillRate; 
} RandomFillStruct;

void RandomFill(Visualization * vis)
{
    RandomFillStruct state;

    // load state
    VisLoadObject(vis,&state,sizeof(state));


    // initialize
    if (vis->frame == 0)
    {
        state.sync = rand8()>127; // when to sync them

        int rate = randMod2(3,8); // 3-7 times a second

        if (!state.sync)
        {   // update change in fill rate each frame, randomly spread
            ParticleInit(&state.fillRate,0,0,rate*NUM_PIXELS,2,3,vis->fps,DIRECTION_POSITIVE);
        }
        else
        {   // update all at once when rate wraps
            ParticleInit(&state.fillRate,0,1,rate,1,1,vis->fps,DIRECTION_POSITIVE); 
        }
    }

    int32_t i,j,r,g,b;
    uint32_t rd;
    if (state.sync)
    { // fill all
        if (ParticleUpdate(&state.fillRate,0,1,ENDPOINT_WRAP))
        {
            for (i = 0; i < NUM_PIXELS; ++i)
            {
                rd = rand32(); // random RGB
                r = (rd>>16)&255;
                g = (rd>>8)&255;
                b = (rd)&255;
                SetPixel(i,r,g,b);
            }
        }
    }
    else
    { // fill some
        FixedPoint start = state.fillRate.value;
        FixedPoint end = 0;
        if (ParticleUpdate(&state.fillRate,0,NUM_PIXELS,ENDPOINT_WRAP))
            end += FixedPoint(NUM_PIXELS);
        end += state.fillRate.value;
        int32_t count = FixedPointToInteger(end) - FixedPointToInteger(start);
        for (j = 0; j < count; ++j)
        {
            i = randUniform(NUM_PIXELS);
            rd = rand32(); // random RGB
            r = (rd>>16)&255;
            g = (rd>>8)&255;
            b = (rd)&255;
            SetPixel(i,r,g,b);
        }
    }


    // save state
    VisSaveObject(vis,&state,sizeof(state));
}

#if 0
// draw a clock time as binary
// todo - make each part of number a different color, length, move lengths, bouncing them
void Clock(Visualization * vis)
{
#define RATE 100 // beats per second
    if (vis->frame == 0)
    { // initialize
        vis->fps = RATE;
    }

    // compute time parts
    uint32_t f = vis->frame;
    int hundredths = f%RATE;
    int seconds    = (f/RATE)%60;
    int minutes    = (f/(RATE*60))%60;
    int hours      = (f/(RATE*60*60))%24;
    int days       = (f/(RATE*60*60*24));

    Fill(0,0,0);

// write n-bit value out at position
// writes delimeter at each end, with binary value in between
// colors should point to an array of 3 RGB colors:
//    lowest is delimeter color, then bit set color, then bit clear color
// if colors is NULL, then use red, blue, white
    // color: delimiter, 1 bit, 0 bit
    static const uint8_t redColors  [] = {255,0,255, 255,255,255, 255,0,0};
    static const uint8_t greenColors[] = {255,0,255, 255,255,255, 0,255,0};
    static const uint8_t blueColors [] = {255,0,255, 255,255,255, 0,0,255};

    // position, value, bit length, colors
    DisplayPositionedInteger(0,  hundredths, 10, redColors  );
    DisplayPositionedInteger(11, seconds   ,  6, greenColors);
    DisplayPositionedInteger(18, minutes   ,  6, blueColors );
    DisplayPositionedInteger(25, hours     ,  5, redColors  );
    DisplayPositionedInteger(31, days      , 20, greenColors);

#undef RATE
}
#endif

typedef struct
{
} TestColorBatchState;

void TestColorBatch(Visualization * vis)
{
    TestColorBatchState state;

    // load settings
    VisLoadObject(vis,&state,sizeof(state));

    ColorBatch_t * cb = &(vis->colorBatch);

    if (vis->frame == 0)
    { // initialize

#if 1
        ColorSchemeName_t type = randMod2(COLOR_SCHEME_First,COLOR_SCHEME_Last+1);
        bool addComp = rand8()>127?true:false;
        int satLum = randMod2(1,6);

        type = COLOR_SCHEME_Triad;
        satLum = 7;
        ColorBatchInit(
            cb,            // the color batch to process
            type,          // the color scheme, which determines basic color combinations
            addComp,       // adds complementary color to the primary for those without
            satLum,        // satlum combos per per hue
            -1,            // integer 1-4 for analagous - quads 1-4, -1 for random
            0,             // inclusive lower bound for random primary hue
            HSLMAX+1,      // exclusive upper bound for random primary hue
            3*HSLMAX/4,    // min saturation for spacing
            HSLMAX,        // max saturation for spacing
            HSLMAX/2,      // min lightness for spacing
            HSLMAX/2,      // max lightness for spacing
            FixedPoint(1), // speed
            vis->fps       // frames per second for updates, sets default animation rates
            );

        //cb->animation.hueShift.particle.delta = 0; // no movement

        Print("Color type %s, add comp %d. satLum %d"ENDLINE,ColorSchemeName(type),addComp,satLum);

        // write out color batch info for debugging
        ColorBatchDebugOutput(cb);
        Print(ENDLINE ENDLINE);
#else
        ColorBatchInitSimple(
            cb,      // the color batch to initialize
            1,       // inclusive min number of distinct hues
            5,       // inclusive max number of distinct hues
            1,       // inclusive min number of shades per hue
            7,       // inclusive max number of shades per hue
            randMod2(FixedPoint(1)/2,FixedPoint(3)),         // animation speed scaling, default to 1, larger is faster
            vis->fps // frames per second for updates, sets default animation rates
        );
        ColorBatchDebugOutput(cb);
        Print(ENDLINE ENDLINE);
#endif

    }

    // update and draw
    Fill(0,0,0);
    ColorBatchUpdate(cb);
    int32_t i,j,t=0;

    SetPixel(t++,255,0,0);

    for (i = 0; i < cb->swatchCount; ++i)
    {
        for (j = 0; j < cb->swatches[i].satLightCount; ++j)
        {
            int32_t r,g,b;
            ColorBatchGetRGB(cb,i,j,&r,&g,&b);
            SetPixel(t++,r,g,b);
        }
    }

    SetPixel(t++,255,0,0);

    // save settings
    VisSaveObject(vis,&state,sizeof(state));
}

// texts to show, 0 ends list
static const char * scrollyTexts[] = {
  "This one time, at band camp.....",
  "That rug really tied the room together.",
  "We don't need no stinking badges.",
  "We're on a mission from God.",
  "Thank you very little.",
  "I have nipples, Greg. Could you milk me?",
  "It's a moral imperative.",
  "May the Schwartz be with you.",
  "These go to eleven.",
  "I'll have what she's having",
  "What knockers!",
  "Hello, my name is Inigo Montoya.",
  "As you wish!",
  "Game over man, game over!",
  "We're gonna need a bigger boat.",
  "She turned me into a newt!",
  "Fat, drunk, and stupid is no way to go through life, son.",
  "If I'm not back in five minutes, just wait longer.",
  "Shop smart. Shop S-Mart.",
  0
};

typedef struct
{
    const char * message;
    int8_t length;
    int8_t messageCount;
    int32_t shiftOffset;
} ScrollyState;

static void SetScrollyPixel(int x1, int y1, int r, int g, int b)
{
#define SCROLL_WIDTH 10 // scrolly pixel width    
    // order: top right to left, down one, then to left, down one, to right, etc
    if (0<=x1 && x1< SCROLL_WIDTH && 0<=y1 && y1 <= 4)
    {
        int t = ((y1&1)?x1:(SCROLL_WIDTH-1)-x1)+SCROLL_WIDTH*y1;
        SetPixel(t,r,g,b);
    }
}

static void GetScrollyMessage(ScrollyState * state)
{
    state->message = scrollyTexts[randUniform(state->messageCount)];
    // easter egg :)
    extern bool godMode;
    if (godMode && debugMode && visualizationSettings.demoMode && visualizationSettings.lockCurrentVisualization)
        state->message = "Princess Twinkiebutt";
    state->length = strlen(state->message);
}

void Scrolly(Visualization * vis)
{
    ScrollyState state;

    // load settings
    VisLoadObject(vis,&state,sizeof(state));

    ColorBatch_t * cb = &(vis->colorBatch);

    int32_t i,j;
    if (vis->frame == 0)
    { // initialize
        ColorBatchInitSimple(
            cb,      // the color batch to initialize
            2,       // inclusive min number of distinct hues
            2,       // inclusive max number of distinct hues
            5,       // inclusive min number of shades per hue
            5,       // inclusive max number of shades per hue
            randMod2(FixedPoint(1)/2,FixedPoint(3)),         // animation speed scaling, default to 1, larger is faster
            vis->fps // frames per second for updates, sets default animation rates
        );
        // count 
        i = 0;
        while (scrollyTexts[i] != 0)
            ++i;
        state.messageCount = i;
        state.shiftOffset = 0;
        GetScrollyMessage(&state);
    }
    
    

    // update and draw - think of image as 5x10 image
    ColorBatchUpdate(cb);
    
    
    // draw background
    int hue = vis->frame % (HSLMAX+1);
    int32_t red,green,blue;
    for (i = 0; i < SCROLL_WIDTH; ++i)
    for (j = 0; j < 5; ++j)
    {
        HSLToRGB(hue + i*5,HSLMAX,HSLMAX/2,&red,&green,&blue);
//        ColorBatchGetRGB(cb,0,j,&red,&green,&blue);
        SetScrollyPixel(i,j,red,green,blue);
    }
    Fade(0,0,0,128);
       
    
    
    int k = 0;
    // want SCROLL_WIDTH pixels / 2.5 seconds...
    int shift = SCROLL_WIDTH*vis->frame*10/(vis->fps*25);
    
    shift -= state.shiftOffset; // keep track of when it wraps
    
    // wrap every so many characters times pixel size plus screen size plus gap
    if (shift > state.length * 4 + 10 + 5)
    {
        // new message
        GetScrollyMessage(&state);
        state.shiftOffset += shift;
        shift = 0;
    }

    // back off 3 pixel lead
    shift -= 3;
    
    // shift goes backwards
    shift = 9 - shift;

   
    while (state.message[k] != 0)
    {
        uint16_t bits = Get3x5Char(state.message[k]);

        int x = 0, y = 0; // where to draw, x,y upper left
        x = k*4 + shift;
        y = 0;
        
        // draw 3x5 with spacing of 1
        for (j = 0; j < 5; ++j)
        {
            //ColorBatchGetRGB(cb,1,5-j,&red,&green,&blue);
            HSLToRGB((hue+HSLMAX/2 - i*5),HSLMAX,HSLMAX/2,&red,&green,&blue);
            for (i = 0; i < 3; ++i)
            {
                int pixel = (bits>>14)&1;
                //Print("%d",pixel);
                if (!pixel)
                {                    
                    SetScrollyPixel(x+i,y+j,red,green,blue);
                }
                
                bits<<=1;
            }
            //Print(ENDLINE);
        }
    //Print(ENDLINE);
        ++k;    // next char    
    }
    
#undef SCROLL_WIDTH
    // save settings
    VisSaveObject(vis,&state,sizeof(state));    
}


// end of file


#include "visualization.h"
/*
 * File:   visualization.h
 * Author: Chris
 *
 * Created on June 13, 2014, 12:37 PM
 */

#ifndef VISUALIZATION_H
#define	VISUALIZATION_H

#ifdef	__cplusplus
extern "C" {
#endif

#include "main.h"
#include "buffer.h"
#include "math.h"
#include "BitPack.h"
#include "ColorBatch.h"
#include "SelectTheme.h"
    
// number of bytes in visualization for storing state
#define VIS_STATE_SIZE 256

    struct Visualization;

typedef void (*vis_func)(struct Visualization *);

// visualization structure passed to all visualizations
typedef struct Visualization
{
    // times this has been called
    uint32_t frame;
    // as soon as this frame number is drawn, start next transition or vis, and start to kill this item
    uint32_t endFrame;

    // desired frames per second. Initialized to default, can be changed on the fly
    int16_t fps;

    // needed local random state, prevents various tasks
    // from using too many rands, screwing up repeatability
    // due to cache and other timing issues
    RandState_t randState;

    // pointer to the task running this visualization
    Task_t * task;

    // the draw image function
    vis_func visualizationFunc;

    // store any state here, using functions to read/write it to prevent buffer overflows
    uint8_t state[VIS_STATE_SIZE];

    // simpler state used to lower code size for many uses
    // can be read/written directly, do not use functions
    uint32_t simpleState1;

    // each visualization has one color batch. Must be initialized in the
    // visualization. It is not initialized by the internals
    ColorBatch_t colorBatch;

    // set to true once transition starts
    bool ending;

    // where drawing goes to
    ImageBuffer_p drawBuffer;

    // where theme mapped buffer goes to
    ImageBuffer_p themedBuffer;

    // the theme to map this to after rendering
    Theme_t theme;

    // internal use only. Do not modify in a visualization
    // used to track bytes stored in objects
    int bytesWritten;
    int bytesRead;
    int errors;
} Visualization;

// get a Visualization object
Visualization * VisAlloc();

// initialize the visualization structure
// if theme is THEME_NONE then no themeing buffer is allocated, else
// themeing buffer is allocated
void VisInit(Visualization * vis, Task_t * task, Theme_t theme);

// add some ticks to the system
// takes change in ticks from last call in ReadCoreTimer ticks
// if it is time for another frame, return 1, else return 0
int VisAddDeltaTicks(Visualization * vis, uint32_t deltaTicks);

// initialize the visualization structure for each frame
void VisPreFrame(Visualization * vis);

// do any post frame stuff
void VisPostFrame(Visualization * vis);

// load a state object of the given size
// return 1 on success, else 0
// on failure, if frame nonzero, logs an error
int VisLoadObject(Visualization * vis, void * data, int bytes);

// save a state object of the given size
// return 1 on success, else 0
int VisSaveObject(Visualization * vis, void * data, int bytes);

// visualizations
// debugging ones
void RedFill(Visualization * vis);
void GreenFill(Visualization * vis);
void BlueFill(Visualization * vis);
// draw a clock time as binary
void Clock(Visualization * vis);
void TestColorBatch(Visualization * vis);

// under development
void SmileySpinner(Visualization * vis);


// general ones
void Bouncer(Visualization * vis);
void Plasma(Visualization * vis);
void Blocks(Visualization * vis);
void Splat(Visualization * vis);
void SolidFill(Visualization * vis);

void Bouncy(Visualization * vis);
void RandomFill(Visualization * vis);
void SolidHue(Visualization * vis);
void CircleHueFast(Visualization * vis);
void CircleHueSlow(Visualization * vis);

void TwoColor(Visualization * vis);
void WhiteColorGradient(Visualization * vis);
void Waves(Visualization * vis);
void Racers(Visualization * vis);
void Sparkle(Visualization * vis);

void NColor(Visualization * vis);
void LayerSlider(Visualization * vis);
void VenetianBlind(Visualization * vis);
void Passings(Visualization * vis);
void Crashes(Visualization * vis);

void InchWorm(Visualization * vis);
void BackAndForth(Visualization * vis);
void MessageSpinner(Visualization * vis);
void Checkerboard(Visualization * vis);
void Shooter(Visualization * vis);

void NewtonHue(Visualization * vis);
void Springs(Visualization * vis);

void UpAndDown(Visualization * vis);
void Fire(Visualization * vis);
void Heartbeat(Visualization * vis);
void HueFlow(Visualization * vis);

void Twinkle(Visualization * vis);
void RandomWalker(Visualization * vis);
void Cellular1D(Visualization * vis);
void MorseCode(Visualization * vis);
void Runner(Visualization * vis);

void Scrolly(Visualization * vis);

typedef struct
{
    // the function to call to draw the visualization
    vis_func function;
    
    // text description
    const char * name;
    
    bool allowByDefault; // some we don't allow on a reset or by default
} VisEntry_t;

// a list of visualization entries. Last one has NULL function and name.
extern const VisEntry_t * visualizations;

#ifdef	__cplusplus
}
#endif

#endif	/* VISUALIZATION_H */




#include "colors.h"

/* 
 * File:   colors.h
 * Author: Chris
 *
 * Created on July 22, 2014, 5:29 PM
 */

#ifndef COLORS_H
#define	COLORS_H

#ifdef	__cplusplus
extern "C" {
#endif

// HSL color model:

// hue, sat, lum in this range 0-HSLMAX inclusive
// HSLMAX should be one less than a power of 2
#define HSLMAX 511

/// Convert Hue,Saturation,Luminance (HSL)
/// or Hue,Saturation,Value (HSV) to
/// Red,Green,Blue (RGB) in 0,1.
/// If Hue were in [0,511):
///    red    = 0
///    violet = 85
///    blue   = 170
///    cyan   = 255
///    green  = 341
///    yellow = 426

#define REDHUE      0
#define VIOLETHUE  85
#define BLUEHUE   170
#define CYANHUE   255
#define GREENHUE  341
#define YELLOWHUE 426

/// RGB to HSL converter, integer based
/// RGB each in 0-255, HSL each in 0-HSLMAX inclusive
void RGBToHSL(
    int32_t red, int32_t green, int32_t blue,
    int32_t * hue, int32_t * saturation, int32_t * luminance
    );

// HSL to RGB converter, integer based
// RGB each in 0-255, HSL each in 0-HSLMAX inclusive
void HSLToRGB(
    int32_t hue, int32_t saturation, int32_t luminance,
    int32_t * red, int32_t * green, int32_t * blue
    );

/* remap hue using a nice scaling, which pulls colors out a little more richly */
int32_t ScaleHue(int32_t hue);


// given color from RGB in 0-255, gives a gamma corrected value in 0-255
extern const uint8_t gammaCorrectionTable[];


// given color from RGB in 0-255, gamma correct it to value in 0-65535
// gamma 2.8 from Table[Round[65535*(i/255)^2.8],{i,0,255}]
extern const uint16_t gammaCorrectionTable16[];

#ifdef	__cplusplus
}
#endif

#endif	/* COLORS_H */



#include "math.h"
/* 
 * File:   math.h
 * Author: Chris
 *
 * Created on June 13, 2014, 1:54 PM
 */

#ifndef MATH_H
#define	MATH_H

#ifdef	__cplusplus
extern "C" {
#endif

#include "main.h"

// fixed point is s15.16
#define FIXED_SHIFT 16

typedef int32_t FixedPoint;

#define FixedPoint(integer) ((integer)<<FIXED_SHIFT)

// multiply two fixed point values
FixedPoint FixedPointMultiply(FixedPoint a, FixedPoint b);

// divide two fixed point values a/b
FixedPoint FixedPointDivide(FixedPoint a, FixedPoint b);

// compute sqrt, using iteration
FixedPoint FixedPointSqrt(FixedPoint a);

// clamp to [min,max] inclusive
int32_t Clamp(int32_t value, int32_t min, int32_t max);

// compute sin of angle where [0,1] represents a whole revolution (not the usual 360)
// output in range [0,1] as fixed point
FixedPoint Sin(FixedPoint angle);

// compute cos of angle where [0,1] represents a whole revolution (not the usual 360)
// output in range [0,1] as fixed point
FixedPoint Cos(FixedPoint angle);

// compute gamma squeezed color where input is in [0,1]
// output in range [0,1] as fixed point
FixedPoint Gamma(FixedPoint color);

// get the integral part of a fixed point value
#define FixedPointToInteger(fp) ((fp)>>FIXED_SHIFT)

// Compute a/b, rounded to the nearest integer, as 32 bit integers
// Requires 2 more bits than numerator requires, one more bit than denominator
int32_t RoundDiv32(int32_t a, int32_t b);

// Compute a%n so that the result is in [0,|n|-1]
// if n == 0, returns a
int32_t PositiveMod(int32_t a, int32_t n);

// given values a and b, and fraction n/d in [0,1],
// compute a+(b-a)(n/d) carefully. Round to nearest bit.
// if d = 0 return (a+b)/2
int32_t LinearInterpolate(int32_t a, int32_t b, int32_t n, int32_t d);

// Fischer-yates shuffle on n items numbered 0 to n-1
// takes n, a parameter to pass to each swap call, and a swap function
// that takes indices i,j and the parameter, and performs a swap
// swap may be called with i,j the same
void Shuffle(int n, void * obj, void (*swapFunc)(int,int,void*));


// copy sign -1,0,1 from an integer (or float) value
#define copysign(a) ((a) < 0 ? -1 : ((a)>0?1:0))

// compute the nth term in a sub-random sequence in [min,max] given
// the initial value. A sub-random sequence covers the space nicely and uniformly,
// and looks better for generating colors, for example.
// http://en.wikipedia.org/wiki/Low-discrepancy_sequence
int32_t LowDiscrepancySequence(int32_t startValue, int32_t minValue, int32_t maxValue, int32_t term);

// compute GCD of a and b
int32_t gcd( int32_t a, int32_t b );

// permute 3 items
void Permute3(int permutation, uint32_t * c1, uint32_t * c2, uint32_t * c3);


// return index 0..63 of least significant bit set
// requires value to be nonzero
int bitScanForward(uint64_t value);

// return number 0-64 of bits set
int BitCount(uint64_t value);


#ifdef	__cplusplus
}
#endif

#endif	/* MATH_H */



#include "SmileyData.c"

// width,height of image 300,25
// data stored as RGB, then count to repeat, then RGB, starting anew on each row
// r,g,b are bytes, count is low byte then high byte
static const unsigned char smileyData[]={
#if 0
56,248,248,44,1, // row 0, 5 bytes on line
56,248,248,44,1, // row 1, 5 bytes on line
56,248,248,44,1, // row 2, 5 bytes on line
56,248,248,44,1, // row 3, 5 bytes on line
56,248,248,44,1, // row 4, 5 bytes on line
56,248,248,44,1, // row 5, 5 bytes on line
56,248,248,44,1, // row 6, 5 bytes on line
56,248,248,250,0,59,220,219,251,0,16,74,74,252,0,9,42,42,253,0,5,22,22,254,0,0,0,0,2,1,5,22,22,3,1,9,42,42,4,1,55,240,240,5,1,56,248,248,44,1, // row 7, 50 bytes on line
56,248,248,190,0,54,222,221,191,0,54,222,220,192,0,57,221,220,193,0,56,248,248,242,0,16,74,74,243,0,0,0,0,9,1,56,240,240,10,1,56,248,248,44,1, // row 8, 45 bytes on line
56,248,248,183,0,16,74,74,184,0,0,0,0,201,0,5,22,22,202,0,56,248,248,239,0,16,74,74,240,0,0,0,0,9,1,56,248,248,44,1, // row 9, 40 bytes on line
56,248,248,182,0,16,74,74,183,0,0,0,0,205,0,56,240,240,206,0,56,248,248,237,0,21,94,94,238,0,0,0,0,7,1,16,74,74,8,1,56,248,248,44,1, // row 10, 45 bytes on line
56,248,248,183,0,21,94,94,184,0,0,0,0,208,0,56,248,248,236,0,16,74,74,237,0,0,0,0,6,1,56,248,248,44,1, // row 11, 35 bytes on line
56,248,248,184,0,16,74,74,185,0,0,0,0,209,0,16,74,74,210,0,56,248,248,235,0,16,74,74,236,0,0,0,0,3,1,5,22,22,4,1,24,111,111,5,1,56,248,248,44,1, // row 12, 50 bytes on line
56,248,248,35,0,21,94,94,36,0,0,0,0,38,0,5,22,22,39,0,0,0,0,110,0,56,248,248,187,0,0,0,0,211,0,56,248,248,235,0,16,74,74,236,0,0,0,0,1,1,5,22,22,2,1,21,94,94,3,1,56,248,248,44,1, // row 13, 65 bytes on line
56,248,248,5,0,0,0,0,7,0,5,22,22,8,0,56,237,239,9,0,56,248,248,19,0,55,246,246,20,0,56,248,248,21,0,0,0,0,22,0,5,22,22,23,0,0,0,0,35,0,5,22,22,36,0,0,0,0,39,0,5,22,22,40,0,0,0,0,43,0,0,0,255,50,0,0,0,0,55,0,0,0,255,64,0,0,0,0,67,0,21,94,94,68,0,56,248,248,109,0,0,0,0,111,0,5,22,22,112,0,0,0,0,128,0,56,241,241,129,0,56,248,248,148,0,0,0,0,151,0,56,248,248,189,0,21,94,94,190,0,0,0,0,211,0,56,248,248,235,0,16,74,74,236,0,0,0,0,255,1,5,22,22,0,1,56,248,248,44,1, // row 14, 170 bytes on line
56,248,248,7,0,16,74,74,8,0,0,0,0,22,0,56,248,248,40,0,0,0,0,43,0,0,0,255,51,0,0,0,0,54,0,0,0,255,63,0,0,0,0,66,0,16,74,74,67,0,56,248,248,125,0,56,241,242,126,0,0,0,0,150,0,16,74,74,151,0,56,248,248,191,0,21,94,94,192,0,5,22,22,193,0,0,0,0,211,0,56,248,248,236,0,16,74,74,237,0,0,0,0,252,0,5,22,22,253,0,56,248,248,44,1, // row 15, 115 bytes on line
56,248,248,8,0,16,74,74,9,0,0,0,0,10,0,16,74,74,11,0,56,248,248,41,0,16,74,74,42,0,0,0,0,44,0,0,0,255,51,0,0,0,0,54,0,0,0,255,62,0,0,0,0,64,0,16,74,74,65,0,56,248,248,144,0,0,0,0,149,0,16,74,74,150,0,56,248,248,194,0,21,94,94,195,0,5,22,22,196,0,0,0,0,210,0,16,74,74,211,0,56,248,248,238,0,0,0,0,248,0,5,22,22,249,0,21,94,94,250,0,56,248,248,44,1, // row 16, 125 bytes on line
56,248,248,7,0,0,0,0,10,0,56,248,248,43,0,0,0,0,46,0,0,0,255,52,0,0,0,0,54,0,0,0,255,61,0,0,0,0,63,0,16,74,74,64,0,56,248,248,148,0,0,0,0,149,0,16,74,74,150,0,56,248,248,198,0,21,94,94,199,0,0,0,0,209,0,16,74,74,210,0,56,248,248,240,0,21,94,94,241,0,0,0,0,244,0,5,22,22,245,0,21,94,94,246,0,56,248,248,44,1, // row 17, 110 bytes on line
56,248,248,44,0,21,94,94,45,0,5,22,22,46,0,0,0,0,47,0,0,0,255,58,0,0,0,0,61,0,16,74,74,62,0,56,248,248,202,0,16,74,74,203,0,0,0,0,205,0,5,22,22,206,0,16,74,74,207,0,21,94,94,208,0,56,248,248,44,1, // row 18, 70 bytes on line
56,248,248,46,0,21,94,94,47,0,5,22,22,48,0,0,0,0,58,0,21,94,94,59,0,56,248,248,44,1, // row 19, 30 bytes on line
56,248,248,44,1, // row 20, 5 bytes on line
56,248,248,44,1, // row 21, 5 bytes on line
56,248,248,44,1, // row 22, 5 bytes on line
56,248,248,44,1, // row 23, 5 bytes on line
56,248,248,44,1, // row 24, 5 bytes on line
#endif
};

// Indices to row starts
static const unsigned short smileyRowStarts[]={
0,5,10,15,20,25,30,35,85,130,170,215,250,300,365,535,650,775,885,955,985,990,995,1000,1005,};
// 1060 total bytes


#include "VisHelpers.h"

/* 
 * File:   VisHelpers.h
 * Author: Chris
 *
 * Created on December 5, 2014, 12:27 PM
 */

#ifndef VISHELPERS_H
#define	VISHELPERS_H

#ifdef	__cplusplus
extern "C" {
#endif

/* Visualization tools
 * Here are some utility tools that make visualization easier to write
 *
 * 1. PACK/UNPACK macros for simple states
 * 2. Particle - has position, delta, update functions
 * 3. Hump     - has position, width, height, makes a hump
 * 4. Color selection, next, management functions
 * 5. Various random and speed dependendt computation functions
 */

/* TODO
 * 1. unify various random value creators
 *    - int range
 *    - frame rate dependent values
 *    - in bounds [a,b] or [-b,-a] with return on which selected
 * 2. Bounce API Bounce(min,max,cur,delta, bool clamp, bool snap)
 *    - which clamps and/or snaps to end, then does delta, modifies delta
 * 3. Color API and struct...
 * 4. Divisors of length API
 *    - want # runs, run length (s)
 *    - give min length, max length (or -1) for any
 *    - give min runs, max runs (or -1 for any)
 *    - give # in range
 *    - pick combo unif randomly
 *    - structure to hold?
 *    - require even/odd #, or don't care
 *    - require precise divisor, or sloppy divisor
 *    - want things like 1/3, 1/2, 1/4, etc, of length?
 *    - want choice from things like 1/2,1/4,1/8...
 * 5. "hump" object
 *    - is a bump, that smoothly is 0, then up to height h, then back to 0
 *    - take 1-cos where cos over [0,1]->[0,1]
 *    - has particle (pos,delta) for height, width, position
 *    - func to eval a hump at a parameter
 * 6. SatLight object
 *    - creates nice sat/light variations for pure hues
 */

#include "main.h"
#include "Particle.h"
#include "Hump.h"
#include "ColorBatch.h"

/******************************** divisors section ****************************/


// pick a random run length,run count pair randomly meeting requirements
// returns number of runs, and fills in array of run lengths
// if exact required, only fills in one run length, since all are same
// if no legal runs, returns 1 and one run length filled in
// max number of runs is going to be the same as NUM_PIXELS, but in general is 
// at most maxRunCount
int32_t GetRunsCount(
        uint16_t * runLengths,  // run lengths, must be enough to hold possible answers
        int32_t minRunCount,    // min number of runs, or -1 for don't care
        int32_t maxRunCount,    // max number of runs, or -1 for don't care
        int32_t minLength,      // min run length, -1 for don't care
        int32_t maxLength,      // max run length, -1 for don't care
        uint32_t extraRuns,     // bit n=0,1,..,31 set if (n+1) desired to be a # of runs
        bool allowEvenRunCount, // allow even # of run counts
        bool allowOddRunCount,  // allow odd number of runs
        bool requireExact       // require exact divisors
);
// helper for the extra divisors parameter in GetRunsCount
// n is 1,2,3,..,31
#define RUN(n) (1UL<<(n-1))

// given the run lengths, the number of them, and an index i,
// return the index where i is. Returns last value +1 if off end
// if offset not NULL, return how far into the run this index is
int GetRunIndex(int i, const uint16_t* runLengths, int numRuns, int*offset);

// given the run lengths, the number of them, and an index i,
// return the 0-based inclusive start and exclusive end position
// if either start or end index is NULL, it is ignored
void GetRunPosition(int i, const uint16_t* runLengths, int numRuns, int32_t * startIndex, int32_t * endIndex);

/******************************** SatLight section ****************************/

typedef struct
{
    Hump_t hump;
} SatLight_t;

// Initialize a saturation/lightness modifier
// speed is default 1, higher numbers move faster
// fps is the frames per second to render at
void SatLightInit(SatLight_t * satLight, FixedPoint speed, int32_t fps);

void SatLightUpdate(SatLight_t * satLight);

// for a given pixel position 0-NUM_PIXELS, get a saturation/lightness as asked
// parameters can be NULL
void SatLightGetSL(const SatLight_t * satLight, int pixelIndex, int32_t * saturation, int32_t * lightness);


/******************************** misc section ********************************/


// compute a delta so that the sum is between min and max,
// over given min and max time in seconds, at given frames per second
FixedPoint PerFrameRandomAmount(FixedPoint minVal, FixedPoint maxVal, FixedPoint minTime, FixedPoint maxTime, int32_t fps);

// add a value, wrap around the given mod
FixedPoint AddFixedPointMod(FixedPoint value, FixedPoint dValue, FixedPoint modulus);





#ifdef	__cplusplus
}
#endif

#endif	/* VISHELPERS_H */



#include "ColorBatch.h"

/* 
 * File:   ColorBatch.h
 * Author: Chris
 *
 * Created on December 8, 2014, 11:35 AM
 */

#ifndef COLORBATCH_H
#define	COLORBATCH_H

#ifdef	__cplusplus
extern "C" {
#endif

#include "main.h"
#include "Particle.h"

/******************************** Color management ****************************/

/* API usage:
 *
 * A color batch is a collection of hues, each with a subcollection of
 * saturation/luminance pairs (called a swatch). All of these are animatable.
 * 
 * 1. Use  ColorBatchInit or ColorBatchInitSimple to initialize a color batch
 * 2. Call ColorBatchUpdate once per frame
 * 3. Call ColorBatchGetRGB or ColorBatchGetHSL to get colors
 * 4. Optionally, set animation parameters individually
 *
 */

// max number of sat/light items stored per hue in the color swatches
#define MAX_HUES_PER_SCHEME  5  // 4 base hues per theme allowed, and one optional primary complement
#define MAX_SATLIGHT_PER_HUE 7  // 7 max s/l pairs allowed per hue

// scheme of colors to pick
typedef enum {
    COLOR_SCHEME_First,
    COLOR_SCHEME_Monochrome = COLOR_SCHEME_First, // single color
    COLOR_SCHEME_Analogous,          // Hue varies 1/12, 2/2, or 3/12 of the way around, in 1/12 steps (so colors spread over 4 or less steps)
    COLOR_SCHEME_SplitAnalogous,     // Hue varies -2,0,2  12ths of the way around (like analogous, but skips some)
    COLOR_SCHEME_Complementary,      // Hues opposite, 6/12th away around circle
    COLOR_SCHEME_SplitComplementary, // Hue varies +- 5/12 of the way around (i.e., complementary, then off one)
    COLOR_SCHEME_Triad,              // Three hues equally spaced around circle (-4/12,0,+4/12)
    COLOR_SCHEME_Tetrad,             // Four hues equally spaced around circle
    COLOR_SCHEME_DoubleComplements,  // Four hues, at 0/12, 2/12, 6/12, and 8/12 around the circle.
    COLOR_SCHEME_Neutral,            // Black and white (gray scale)
    COLOR_SCHEME_AccentedNeutral,    // One hue (light to pure or so) with black and white (grayscale)
    COLOR_SCHEME_Last = COLOR_SCHEME_AccentedNeutral
} ColorSchemeName_t;

// get color scheme name given the symbolic one
const char * ColorSchemeName(ColorSchemeName_t type);

typedef enum
{
    CHANNEL_HUE,
    CHANNEL_SATURATION,
    CHANNEL_LIGHTNESS,
} ColorChannelType_t;

// structure holding parameters for nice controls to animate
// saturation/lightness parameters
// see the explanation for how this works at the function documentation
typedef struct
{
    BoundedParticle_t baseSaturation; // central saturation in [0,HSLMAX]
    BoundedParticle_t baseLightness;  // central lightness  in [0,HSLMAX]
    BoundedParticle_t distance;       // distance [0,1] represents spacing in [0,1] square
    BoundedParticle_t angle;          // angle in [0,1], represents [0,360] degrees
} SaturationLightnessGadget_t;

// a swatch of colors is a dark to light version of a color
// it has a list of saturation/lightness pairs
typedef struct
{
    uint8_t satLightCount; // number of saturation/lightness pairs used
    FixedPoint sats[MAX_SATLIGHT_PER_HUE]; // the saturations
    FixedPoint lums[MAX_SATLIGHT_PER_HUE]; // the lightnesses
} ColorSwatch_t;

// animatible parameters for a color batch
typedef struct
{
    // sat/light control for swatches
    SaturationLightnessGadget_t satLightGadgets[MAX_HUES_PER_SCHEME];
    // amount hues have been shifted, applied to all swatches during color reading
    BoundedParticle_t hueShift;
    // amount hue spacing for the scheme is stretched
    BoundedParticle_t hueScale;
} ColorBatchAnim_t;

// struct to track a batch of colors
// allows them to be treated/animated as a group
typedef struct
{
    // the scheme this object monitors
    ColorSchemeName_t colorScheme;
    // index of the primary hue swatch
    uint8_t swatchPrimaryIndex;
    // count of swatches used (also number of hues used)
    uint8_t swatchCount;       
    // color swatches to manage
    ColorSwatch_t swatches[MAX_HUES_PER_SCHEME];
    // primary hue for the scheme
    FixedPoint primaryHue;
    // delta hues from primary for each swatch
    FixedPoint deltaHues[MAX_HUES_PER_SCHEME];
    // number of distinct colors managed (swatch count * number of sat/light pair per swatch)
    uint8_t colorCount;
    // the color batch animation container
    ColorBatchAnim_t animation;
} ColorBatch_t;

// given swatch and gadget, with count filled in swatch and all parameters in gadget,
// fill in the swatch saturation/lightness pairs
// This takes a point in the SL square, an angle for a line through that point,
// a number of SL pairs desired, and a distance to the farthest point. From
// that it computes SL points, and any outside the bounds of the SL square
// are projected back towards the center of the SL square to the boundary
void ColorBatchPrepareSatLightPairs(
    ColorBatch_t * colorBatch, // the color batch to process
    int swatchIndex            // swatch item to modify
    );


typedef enum
{
    ANIMATE_HUESHIFT,
    ANIMATE_HUESCALE,
    ANIMATE_SATCENTER,
    ANIMATE_LIGHTCENTER,
    ANIMATE_DISTANCE,
    ANIMATE_ANGLE,
} ColorBatchAnimateField_t;


// get RGB color in [0,255] each
void ColorBatchGetRGB(
    ColorBatch_t * colorBatch, // the color batch to read from
    int swatchIndex,           // swatch of color index
    int satLightIndex,         // sub index in the swatch
    int32_t * red, int32_t * green, int32_t * blue
);

// get HSL color in [0,HSLMAX] each
// H,S,L may be NULL if ignored
void ColorBatchGetHSL(
    ColorBatch_t * colorBatch, // the color batch to read from
    int swatchIndex,           // swatch of color index
    int satLightIndex,         // sub index in the swatch
    int32_t * hue, int32_t * saturation, int32_t * lightness
);

/* Initialize a color batch
 * todo - test API , document
*
 */
void ColorBatchInit(
    ColorBatch_t * colorBatch,     // the color batch to process
    ColorSchemeName_t colorScheme, // the color scheme, which determines basic color combinations
    bool addComplement,            // adds complementary color to the primary for those without

    int satLightCount,             // satlum combos per per hue
    int analagousCount,            // integer 2-4 for analagous scheme, -1 for random

    int32_t primaryHueMin,         // inclusive lower bound for random primary hue
    int32_t primaryHueMax,         // exclusive upper bound for random primary hue

    int32_t primarySatMin,         // inclusive saturation min for default sat center
    int32_t primarySatMax,         // exclusive saturation max for default sat center
    int32_t primaryLumMin,         // inclusive saturation min for default lightness center
    int32_t primaryLumMax,         // exclusive saturation max for default lightness center

    FixedPoint speedScale,         // animation speed scaling, default to 1, larger is faster
    int fps                        // frames per second for updates, sets default animation rates
);

// simpler batch initialization
void ColorBatchInitSimple(
    // color scheme parameters
    ColorBatch_t * colorBatch,     // the color batch to initialize
    int hueCountMin,               // inclusive min number of distinct hues
    int hueCountMax,               // inclusive max number of distinct hues
    int shadeCountMin,             // inclusive min number of shades per hue
    int shadeCountMax,             // inclusive max number of shades per hue
    FixedPoint speedScale,         // animation speed scaling, default to 1, larger is faster
    int fps                        // frames per second for updates, sets default animation rates
);


// update any internals for the color batch
// handles animation parameter updates
void ColorBatchUpdate(ColorBatch_t * colorBatch);

// write out color batch info for debugging
void ColorBatchDebugOutput(ColorBatch_t * colorBatch);

// make random colors, spaced over the entire ranges given
void MakeRandomColors(
    int count,             // number of colors to make
    int32_t * hues,        // place to store the resulting hues
    int32_t * saturations, // place to store the resulting saturations
    int32_t * lightnesses, // place to store the resulting lightnesses

    int32_t hueMin,        // inclusive lower bound for random hue
    int32_t hueMax,        // exclusive upper bound for random hue
    int32_t satMin,        // inclusive lower bound for random saturation
    int32_t satMax,        // inclusive upper bound for random saturation
    int32_t lumMin,        // inclusive lower bound for random lightness
    int32_t lumMax         // inclusive upper bound for random lightness
    );



// simple function - given a hue, pick a random one that is
// between minDist and maxDist from it, where dist is in tenths of a % around
// the whole hue circle
// either min or max set to -1 makes them full range
// DIRECTION_NEGATIVE, DIRECTION_POSITIVE, or DIRECTION_RANDOM
int32_t NextHue(int32_t hue, int32_t minDist, int32_t maxDist, DirectionMode_t direction);

// given color in [0,1] fixed point, map to 0-255
int32_t FixColor01(FixedPoint c);

#ifdef	__cplusplus
}
#endif

#endif	/* COLORBATCH_H */


#include "SelectTheme.h"
/* 
 * File:   ThemeSelect.h
 * Author: Chris
 *
 * Created on October 3, 2014, 1:14 PM
 */

#ifndef SELECTTHEME_H
#define	SELECTTHEME_H

#ifdef	__cplusplus
extern "C" {
#endif

#include "main.h"
#include "Flash.h"
#include "ColorMapper.h"


// the theme types for playback
// these must be sequential, and 0 based
typedef enum
{
    THEME_NONE,         // null value for themes

    THEME_FIRST_MULTICOLOR, // start of multicolor themes (inclusive)
            
    THEME_ALL = THEME_FIRST_MULTICOLOR,  // default mode is all colors in theme
    
            
    THEME_CHRISTMAS,    // 
    THEME_THANKSGIVING, //
    THEME_HALLOWEEN,    //
    THEME_JULYFOURTH,   //
    THEME_EASTER,       //
    THEME_STPATS,       //
    THEME_VALENTINES,   //

    THEME_LAST_MULTICOLOR = THEME_VALENTINES, // end of holiday themes (inclusive))

    THEME_FIRST_PURE_COLOR, // start of pure color definitions (inclusive))
            
    // 6 color wheel colors
    THEME_RED = THEME_FIRST_PURE_COLOR, // reuse the same value
    THEME_MAGENTA,
    THEME_BLUE,
    THEME_CYAN,
    THEME_GREEN,
    THEME_YELLOW,
            
    // popular colors not above
    THEME_PURPLE,
    THEME_ORANGE,
    THEME_PINK,            
            
    // theme most requested after first release
    THEME_WHITE,

    THEME_LAST_PURE_COLOR = THEME_WHITE, // end of pure color definitions (inclusive))
            
/*

1. Get list of popular colors, add more themes (decreasing popularity)
	1. http://www.thetoptens.com/top-ten-favorite-colors/ :
	   blue, green, red, purple, black, orange, yellow, gold, white, pink
	2. https://blog.kissmetrics.com/gender-and-color/ :
	   Men:   blue, green, red, black, orange, yellow, brown, gray, white
       Women: blue, purple, green, red, black, orange, yellow, brown
	3. http://www.wetcanvas.com/forums/archive/index.php/t-238423.html :
	   blue, purple,
*/

    THEME_CUSTOM,
    THEME_PAST_END            // make this one past the last valid one
} Theme_t;


// random theme
Theme_t GetRandomTheme();


    
// how various themes are demonstrated on startup
void DrawTheme(Theme_t theme, int frame);


// how various themes are demonstrated on startup and during selection
void DrawTheme(Theme_t theme, int frame);

// saves theme to flash to survive a power cycle
// return 1 on success, else 0
int SaveThemeSettings();

// return 1 on success, else 0
int LoadThemeSettings();


// where theme settings live
extern const FlashRegion_t * themeFlashRegion;
#define THEME_SETTING_NAME "Theme"

#define THEME_SAVE_BITS (USER_PROFILE_BIT_PACK(32)) // number of bits required to save theme state

// the most colors a theme can hold
#define MAX_THEME_COLORS        4

// defines per-theme properties
typedef struct
{
    // the theme name
    Theme_t themeStyle;

    // name of the theme text
    const char * themeName;

    // number of colors defining the theme, used for theme selection & mapping
    uint8_t numColors;

    // See ColorRange for details
    ColorRange colorRanges[MAX_THEME_COLORS];

    // relative frequency of each color range
    // all should be 1 or greater
    int relativeFrequencies[MAX_THEME_COLORS];
    
} ThemeDefinitionStruct;

// output a theme definition
void DumpThemeDef(const ThemeDefinitionStruct * def);

// get a pointer to the theme data
const ThemeDefinitionStruct * GetThemeData(Theme_t theme);

// get the name of the theme
const char * GetThemeName(Theme_t theme);

// get the current theme
Theme_t GetActiveTheme();


// call this when a theme changes - it updates theme structures
// it does NOT save changes to flash
void ApplyThemeChange(Theme_t newTheme); 

// calling this causes next theme change to add to current one
void AddNextThemeColor();

// theme state, used for construction of theme, etc.
typedef struct 
{
    // if next theme change is a color, adds to current theme
    bool addNextColor; 
    
    // current theme colors making the current theme
    // empty slots are THEME_NONE
    Theme_t selectedThemes[MAX_THEME_COLORS];
    
}   ThemeSettings_t;


// current theme settings info
extern ThemeSettings_t themeSettings;

// given a theme, add the delta to it, and return the new theme
Theme_t DeltaTheme(Theme_t oldTheme, int delta);
        

#ifdef	__cplusplus
}
#endif

#endif	/* SELECTTHEME_H */


#include "visualizationTask.h"
/* 
 * File:   visualizationTask.h
 * Author: Chris
 *
 * Created on February 12, 2015, 10:43 AM
 */

#ifndef VISUALIZATIONTASK_H
#define	VISUALIZATIONTASK_H

#ifdef	__cplusplus
extern "C" {
#endif

#include "main.h"
#include "flash.h"

// vis tasks have this name
#define VIS_TASK_NAME "Vis"

// how items behaves at end points
typedef enum
{
    // no change requested
    VIS_NO_CHANGE,
    VIS_RESTART_CURRENT,
    // change requested from external commands
    VIS_REQUEST_NEXT_EXTERNAL,
    VIS_REQUEST_PREV_EXTERNAL,
    // change requested for internal reasons
    VIS_REQUEST_NEXT_INTERNAL,
    VIS_REQUEST_PREV_INTERNAL            
} VisChangeRequest_t;

// set this to cause a vis change to happen
// used to move visualization to prev/next when possible
extern VisChangeRequest_t visChangeRequest;

void SpawnNextVisualization(Task_t * visTask);

// removes the proper visualization when a transition is ending
void RemoveVisualizationBecauseTransitionEnding();

// toggles the availability of the current vis in the playlist
void ToggleCurrentVisualizationInPlaylist();

// resets playlist to all items playing
void ResetPlaylist();

// start tasks needed to perform visualizations
void StartVisualizationTasks();
// stop tasks needed to perform visualizations
void StopVisualizationTasks();

// how long to show current visualization in milliseconds
// defaults to  MS_PER_VISUALIZATION
extern uint32_t timeMsForVisualization;

#define MAX_BRIGHTNESS  15
#define MAX_SPEED       15
#define DEFAULT_SPEED   10
#define START_VISUALIZATION_INDEX 0

typedef struct
{
    // set to true and no more transitions will occur
    bool lockCurrentVisualization;
    bool demoMode; // demo mode plays shorter visualizations
    uint8_t brightness; // 0 to MAX_BRIGHTNESS
    uint8_t speed;      // 0 to MAX_SPEED
    uint16_t currentVisualizationIndex;
    bool timer_6_18_on; // true if 6/18 hour timer is on
    
    // bitmask of items to play
    // 1 bit in index i means play item i, 0 means skip
    uint64_t playlistBitmask;
    
    // how long to show current visualization in milliseconds
    uint32_t timeMsForVisualization;
    
    // true if single color, in which case use the following hue
    bool singleColorMode;
    bool singleColorModeWhite; // is the color pure white?
    uint8_t singleColorHue; // 0-127 (top bit is 0)
    
} VisualizationSettings_t;

// single single color hue is 127 (0-127))
#define MAX_SINGLE_COLOR_HUE 127

// given a value which is either a hue 0-MAX_SINGLE_COLOR_HUE or a delta to apply, do it
// if in single color mode, saves new change
void ChangeSingleColorHue(int value, bool treatAsDelta);

extern VisualizationSettings_t visualizationSettings;

/************************ Flash save/load settings ****************************/
// call before running to restore settings from flash
// return 1 on success, else 0
int LoadVisualizationSettings();
   
// return 1 on success, else 0
int SaveVisualizationSettings();

// where visualization settings live
extern const FlashRegion_t * visualizationFlashRegion;
#define VIS_SETTINGS_NAME "Vis settings"

// number of bits required to save state
#define VIS_SAVE_BITS (USER_PROFILE_BIT_PACK(26))


// call before running to restore settings from flash
// return 1 on success, else 0
int LoadPlaylistSettings();
   
// return 1 on success, else 0
int SavePlaylistSettings();

// where playlist settings live
extern const FlashRegion_t * playlistFlashRegion;
#define PLAYLIST_SETTING_NAME "Playlist"

// number of bits required to save state
#define PLAYLIST_SAVE_BITS (USER_PROFILE_BIT_PACK(40))


#ifdef	__cplusplus
}
#endif

#endif	/* VISUALIZATIONTASK_H */

